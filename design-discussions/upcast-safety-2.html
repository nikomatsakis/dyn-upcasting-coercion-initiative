<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Older draft 2 - Dyn upcast initiative</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../index.html">üëã Welcome</a></li><li class="chapter-item "><a href="../updates.html">‚úèÔ∏è Updates</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../updates/2021-oct.html">2021-Oct</a></li></ol></li><li class="chapter-item "><a href="../CHARTER.html">üìú Charter</a></li><li class="chapter-item "><a href="../explainer.html">üìö Explainer</a></li><li class="chapter-item expanded "><a href="../design-discussions/index.html">üí¨ Design discussions</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../design-discussions/definition.html">Definition</a></li><li class="chapter-item expanded "><a href="../design-discussions/upcast-safety-3.html">Upcast safety</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../design-discussions/upcast-safety-3-options.html">Detailed options</a></li><li class="chapter-item expanded "><a href="../design-discussions/upcast-safety-2.html" class="active">Older draft 2</a></li><li class="chapter-item "><a href="../design-discussions/upcast-safety.html">Older draft 1</a></li></ol></li><li class="chapter-item "><a href="../design-discussions/vtable-layout.html">Vtable layout and runtime behavior</a></li></ol></li><li class="chapter-item "><a href="../FAQ.html">üòï FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Dyn upcast initiative</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/dyn-upcasting-coercion-initiative" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/dyn-upcasting-coercion-initiative/edit/master/./design-discussions/upcast-safety-2.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="dyn-upcast-safety"><a class="header" href="#dyn-upcast-safety">Dyn upcast safety</a></h1>
<p><strong>NB: This document is outdated.</strong> <a href="./upcast-safety-3.html">Click here to see the latest version.</a></p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>This doc concerns possible resolutions for the following potential problem:</p>
<ul>
<li>Given:
<ul>
<li>unsize coercions of raw pointers are legal and stable in safe code</li>
<li>upcasting may require loading data from vtable</li>
</ul>
</li>
<li>If:
<ul>
<li>dyn upcast coercions are a kind of unsize coercion</li>
<li>the <a href="#validity-versus-safety-invariants">safety invariant</a> for <code>*const dyn Foo</code> permits an invalid vtable</li>
</ul>
</li>
<li>Then:
<ul>
<li>safe code could cause UB by upcasting a <code>*const dyn SubTrait</code> to a <code>*const dyn SuperTrait</code></li>
</ul>
</li>
</ul>
<p>The doc recommends:</p>
<ul>
<li>Defining the safety invariant for a <code>*const dyn Foo</code> to be a &quot;sufficiently valid&quot; vtable for <code>Foo</code>
<ul>
<li>the definition of &quot;sufficiently valid&quot; is intentionally left undefined except to say:
<ul>
<li>a fully valid vtable is also &quot;sufficiently valid&quot;</li>
<li>it permits upcasting from <code>*const dyn SubTrait</code> to <code>*const dyn SuperTrait</code> without UB</li>
</ul>
</li>
<li>this implies that the only way for users to produce a &quot;sufficiently valid&quot; vtable is with a fully valid one, but conversely safe code cannot rely on a <code>*const dyn Foo</code> having a <em>fully</em> valid vtable</li>
</ul>
</li>
</ul>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<h3 id="unsize-coercions-are-possible-in-safe-code"><a class="header" href="#unsize-coercions-are-possible-in-safe-code">Unsize coercions are possible in safe code</a></h3>
<p>A brief review of the <a href="https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md">DST coercion design</a>:</p>
<ul>
<li>The <code>PT: CoerceUnsized&lt;PU&gt;</code> trait indicates that a smart pointer <code>PT</code> can be coerced to a smart pointer <code>PU</code>
<ul>
<li>This trait is manually implemented for each smart pointer type, e.g. <code>impl&lt;T&gt; CoerceUnsized&lt;Rc&lt;U&gt;&gt; for Rc&lt;T&gt; where T: Unsize&lt;U&gt;</code>.</li>
<li>The compiler requires that <code>Rc&lt;T&gt; -&gt; Rc&lt;U&gt;</code> be a legal DST coercion per various built-in rules (e.g., <code>T</code> must be stored in the final field of the struct and cannot be behind another pointer indirection).</li>
<li>Example: <code>Rc&lt;String&gt;: CoerceUnsized&lt;Rc&lt;dyn Debug&gt;&gt;</code></li>
</ul>
</li>
<li>The <code>T: Unsize&lt;U&gt;</code> trait indicates that the <code>T: ?Sized</code> referent can be &quot;unsized&quot; to the reference <code>U</code>
<ul>
<li>This trait is automatically implemented by the compiler.</li>
<li>Example: <code>String: Unsize&lt;dyn Debug&gt;</code></li>
<li>Example: <code>[String; 32]: Unsize&lt;[String]&gt;</code></li>
</ul>
</li>
</ul>
<p>This design permits one to write generic code that performances unsized coercions, but the trait is unstable so this only works on nightly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Unstable:
fn foo&lt;PT, PU&gt;(pt: PT) -&gt; PU 
where 
    PT: CoerceUnsized&lt;PU&gt;,
{
    pt
}
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=0b3aef50e32fb224bc053f7ef4640e94">Example</a></p>
<p>You can however coerce from a <code>*const T</code> to a <code>*const dyn Trait</code> in safe code on stable (<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=695eeb19aa21e4762b9f5025fea7176c">playground</a>):</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: *const u32 = &amp;32;
    let y: *const dyn std::fmt::Debug = x;
}
</code></pre></pre>
<h3 id="upcasting-dyn-subtrait-to-dyn-supertrait-is-considered-an-unsize-coercion"><a class="header" href="#upcasting-dyn-subtrait-to-dyn-supertrait-is-considered-an-unsize-coercion">Upcasting <code>dyn SubTrait</code> to <code>dyn SuperTrait</code> is considered an unsize coercion</a></h3>
<p>We implemented upcasting from one dyn trait to a supertrait as an upsizing coercion. This means that <code>dyn SubTrait: Unsize&lt;dyn SuperTrait&gt;</code>. This is a coercion because it requires adjusting the vtable.</p>
<h3 id="how-upcasting-coercions-adjust-the-vtable"><a class="header" href="#how-upcasting-coercions-adjust-the-vtable">How upcasting coercions adjust the vtable</a></h3>
<p>The vtable for a <code>dyn SubTrait</code> <a href="https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/vtable-layout.html">now embeds pointers</a> to the vtables for super traits. Upcasting therefore requires loading the new vtable for the supertrait from the specific slot within the subtrait's table.</p>
<p>There are alternatives we could use such that upcasting would be a pure integer adjustment with no load, but that would be less efficient in terms of space usage.</p>
<p>Although not directly relevant here, there is another operation that requires accessing the vtable, which is finding the offset of fields -- see <a href="#mfo">the discussion in the appendices</a> for details. This operation is however only permitted in unsafe code because it requires a dereference of the raw pointer.</p>
<h3 id="ergo-upcasting-raw-pointers-is-possible-in-safe-code"><a class="header" href="#ergo-upcasting-raw-pointers-is-possible-in-safe-code">Ergo, upcasting raw pointers is possible in safe code</a></h3>
<p>Without any further changes, the following upcasting is legal in safe Rust (<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=37e49f69ebf992856b07a430c4d5510f">playground</a>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(trait_upcasting])]

<span class="boring">fn main() {
</span>trait Sub: Sup { }
trait Sup { }

fn convert(x: *const dyn Sub) -&gt; *const dyn Sup {
    x
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="raw-pointers-are-traditionally-permitted-to-be-garbage"><a class="header" href="#raw-pointers-are-traditionally-permitted-to-be-garbage">Raw pointers are traditionally permitted to be &quot;garbage&quot;</a></h3>
<p>A sized raw pointer like <code>*const u32</code> has no validity/safety invariants to speak of. It is not required to be aligned, it may be null, and it may point at arbitrary memory. This is why <code>Option&lt;*const u32&gt;</code> requires an extra word fo the discriminant and it is why dereferencing a raw pointer is unsafe.</p>
<p>However, as noted in the previous section:</p>
<ul>
<li>if upcasting raw pointers is possible in safe code and</li>
<li>if upcasting requires loading data from the vtable</li>
</ul>
<p>then the safety condition of <code>*const dyn Foo</code> must include a &quot;sufficiently valid&quot; vtable. Sufficiently valid means that it is &quot;structurally complete&quot; in that it contains valid pointers that can be loaded to do upcasting.</p>
<h3 id="what-do-we-do-for-null-or-garbage-data"><a class="header" href="#what-do-we-do-for-null-or-garbage-data">What do we do for null or garbage data?</a></h3>
<p>The challenge with <code>*const dyn Trait</code> is &quot;what do we do to make a null pointer&quot;? For better or worse, <code>*const T</code> pointers can traditionally be null: but when one creates a vtable, one is supposed to have some underlying data type to make the vtable for, and with a null pointer that is not possible.</p>
<h3 id="creating-a-const-dyn"><a class="header" href="#creating-a-const-dyn">Creating a <code>*const dyn</code></a></h3>
<p>If we wish to ensure a safety invariant for <code>*const dyn</code> values, we have to ask ourselves how one could go about producing such a value. There are currently two ways to create a <code>*const dyn Trait</code>, one safe and one unsafe:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/ptr/fn.from_raw_parts.html"><code>std::ptr::from_raw_parts</code></a> -- safe, unstable</li>
<li><a href="https://doc.rust-lang.org/std/mem/fn.transmute.html"><code>std::mem::transmute</code></a> -- unsafe, unwise</li>
</ul>
<p>There is also a third way to make a <code>*const T</code> that doesn't work for <code>dyn</code> now but which could be made to work:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/ptr/fn.null.html"><code>std::ptr::null</code></a> -- safe, stable, but currently limited only to <code>*const T</code> where <code>T: Sized</code></li>
</ul>
<p>Of these three:</p>
<ul>
<li><code>from_raw_parts</code> requires a valid vtable for <code>T</code> as argument, so it would meet the safety requirement</li>
<li><code>transmute</code> is unsafe, but it would indeed be a requirement that users of transmute must uphold</li>
<li><code>null</code>, if extended to unsized types, would be tricky -- we would need to have some way to get a &quot;dummy&quot; vtable that is structurally sound enough to permit upcasting, but which has (for example) null pointers for the actual methods. This is, however, eminently doable.</li>
</ul>
<h3 id="interaction-raw-pointer-method-calls"><a class="header" href="#interaction-raw-pointer-method-calls">Interaction: Raw pointer method calls</a></h3>
<p>It would be useful if unsafe code could declare <code>*const self</code> and <code>*mut self</code> methods in traits</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FreeMe {
    pub unsafe fn free_me(*const self);
}
<span class="boring">}
</span></code></pre></pre>
<p>Given that using <code>&amp;self</code> implies (for ex</p>
<h2 id="core-decision-to-be-made"><a class="header" href="#core-decision-to-be-made">Core decision to be made</a></h2>
<p>The core decision to be made is to choose between two paths:</p>
<ul>
<li>Splitting out &quot;unsafe&quot; unsizing operations from safe ones;
<ul>
<li>Unsizing operations on safe pointers like <code>&amp;dyn SubTrait</code> would continue to work as they do today.</li>
<li>Implicit unsizing operations on raw pointers like <code>*const dyn SubTrait</code> would work sometimes, but those unsizing operations that require the metadata meet some sort of condition would require an explicit function call (e.g. the proposal below adds an unsafe function <code>unsize_raw_pointer</code>).</li>
</ul>
</li>
<li>Raw pointers have a validity or safety invariant that puts conditions on metadata 
<ul>
<li>There are options in terms of when this invariant must hold and how strict the invariant must be, but the upshot is that whenever you synthesize the metadata for a raw, wide pointer (e.g., from a transmute), you need to ensure that this metadata comes from some valid source, and is not just garbage. This is contrast to the data pointer, which can generally be arbitrary bytes (though not unininitialized).</li>
</ul>
</li>
</ul>
<h3 id="why-prefer-unsafe-raw-pointer-upcasting"><a class="header" href="#why-prefer-unsafe-raw-pointer-upcasting">Why prefer unsafe raw pointer upcasting?</a></h3>
<p>Raw pointers have traditionally been viewed as &quot;untrusted data until they are used&quot;. This is why dereferencing a raw pointer is unsafe: that's the point where it must be valid. It makes sense to extend this model to the metadata as well. When working with raw pointers and unsafe code, implicit operations like upcasting are a bug, not a feature, so it's useful to segregate them out and make them explicit via some kind of function call. It does require adding a new trait (see below) to the unsizing mechanism, but it only requires an internal &quot;implementation&quot; trait, and doesn't affect the &quot;main trait&quot; (<code>CoerceUnsized</code>).</p>
<p>Besides, so long as the validity/safety invariants remain in flux (which they will be for a while yet), this choice is forwards compatible with the others. We have the option to remove the &quot;unsafe upcast&quot; and merge it with safe upcast and strengthen the relevant invariant(s).</p>
<h3 id="why-prefer-unsafe-some-form-of-invariant"><a class="header" href="#why-prefer-unsafe-some-form-of-invariant">Why prefer unsafe some form of invariant?</a></h3>
<p>It's not clear why one would ever have invalid metadata in a wide pointer to start with; it's not an easy thing to do, you have to basically transmute from random bytes (e.g., zeroed memory). If you want to have a garbage pointer that is not yet initialized, use <code>MaybeUninit</code>. If you want a null pointer, use <code>ptr::null</code> or <code>Option&lt;Unique&lt;_&gt;&gt;</code>. In exchange for following these best practices, you get two things:</p>
<ul>
<li>Safe unsafe code overall, since you are being clearer about your intentions.</li>
<li>A simpler coercion model, with fewer traits and moving parts, and things that work the same for all kinds of pointers</li>
<li>A language that is </li>
</ul>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<p>The following options have been identified. The preferred solution is not yet clear.</p>
<h3 id="rawunsafe-make-raw-pointer-upcasting-unsafe-not-possible-once-dyn-subtrait-unsizedyn-supertrait-is-stable"><a class="header" href="#rawunsafe-make-raw-pointer-upcasting-unsafe-not-possible-once-dyn-subtrait-unsizedyn-supertrait-is-stable">RawUnsafe: Make raw pointer upcasting unsafe (not possible once <code>dyn SubTrait: Unsize&lt;dyn SuperTrait&gt;</code> is stable)</a></h3>
<p>We could permit &quot;safe pointer&quot; upcasting but make raw pointer upcasting unsafe. This would require changing the design of the coercion traits somewhat. We would introduce a new &quot;magic trait&quot; <code>RawUnsize</code>, analogous to <code>Unsize</code> except that it doesn't permit upcasting or any other operations that could require valid metadata. We would then modify the impl of <code>CoerceUnsized</code> for raw pointers to be:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U&gt; CoerceUnsized&lt;*const U&gt; for *const T where
    T: Unsize&lt;U&gt; + ?Sized,
    U: ?Sized, 
<span class="boring">}
</span></code></pre></pre>
<p>and it would become</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U&gt; CoerceUnsized&lt;*const U&gt; for *const T where
    T: RawUnsize&lt;U&gt; + ?Sized,
    U: ?Sized, 
<span class="boring">}
</span></code></pre></pre>
<p>To support upcasting on raw pointers, we can then introduce some other intrinsic for doing raw pointer upcast, such as something like this (modulo stacked borrows, which this <em>particular</em> definition may invalidate):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Unsafefy condition: If the metadata for `T` must be valid.
pub unsafe fn unsize_raw_pointer&lt;T, U&gt;(t: *const T) -&gt; *const U
where
    T: Unsize&lt;U&gt;,
{
    let (_, t_metadata) = t.into_raw_parts();
    unsafe { &amp;*t }
}
<span class="boring">}
</span></code></pre></pre>
<p>So long as <code>Unsize</code> remains a strict superset of <code>RawUnsize</code>, we could change things in the future to make <code>RawUnsize</code> an alias for <code>Unsize</code> (or, if it is unstable, remove it altogether) and thus deprecate the <code>unsize_raw_pointer</code> function. This is therefore forwards compatible with the preferred proposal here as well as other things that say &quot;still possible in the future&quot;.</p>
<h3 id="visufficientlyvalid-extend-the-validity-invariant-of-dyn-trait-to-require-a-sufficiently-valid-vtable"><a class="header" href="#visufficientlyvalid-extend-the-validity-invariant-of-dyn-trait-to-require-a-sufficiently-valid-vtable">VISufficientlyValid: Extend the validity invariant of <code>dyn Trait</code> to require a &quot;sufficiently valid&quot; vtable</a></h3>
<p>One solution is to extend the <a href="#validity-versus-safety-invariants">validity invariant</a> for raw pointers to require a &quot;sufficiently valid&quot; vtable. We don't specify the precise condition that makes a vtable &quot;sufficiently valid&quot; except to say that a fully valid vtable is &quot;sufficiently valid&quot;, and that a &quot;sufficiently valid&quot; vtable permits dyn upcasting without UB.</p>
<p>Implications:</p>
<ul>
<li>Whenever one creates a wide pointer, one must ensure that the metadata is &quot;sufficiently valid&quot;:
<ul>
<li>For <code>*const dyn Trait</code>, this would mean that one must use a valid vtable for <code>Trait</code>.
<ul>
<li>In particular, we don't define what is &quot;sufficiently valid&quot; so you have to use something that is fully valid; at the same time, you cannot rely on the vtable for <code>*const dyn Trait</code> being fully valid yourself, only &quot;sufficiently valid&quot; (which is &quot;valid enough for upcast&quot; and that's it).</li>
</ul>
</li>
</ul>
</li>
<li>If the pointer is not initialized, and hence you don't know which vtable to use, you have the following options:
<ul>
<li>Use a dummy vtable for any type, it doesn't matter which.</li>
<li>Use <code>MaybeUninit&lt;*const dyn Foo&gt;</code>, in which case no safety invariant is assumed.</li>
<li>Use <code>Option&lt;*const dyn Foo&gt;</code> and <code>None</code> instead of null: safer, wastes space.</li>
<li>Use <code>Option&lt;NonNull&lt;dyn Foo&gt;&gt;</code> and <code>None</code> instead of null: safer, generally better, perhaps less ergonomic.</li>
</ul>
</li>
</ul>
<p>One downside of this proposal is that the validity invariant is stricter than is needed: that is, the purpose of the validity invariant is primarily to enable the compiler's ability to perform layout optimizations. This rule would enable the compiler to silently insert upcasting operations if it needed to do so, but it's not clear why it would need to do that spontaneously: those operations are always tied to something else (e.g., a coercion or a method call). Therefore, the safety invariant might seem like a better fit.</p>
<h3 id="sisufficientlyvalid-extend-the-safety-invariant-of-dyn-trait-to-require-a-sufficiently-valid-vtable"><a class="header" href="#sisufficientlyvalid-extend-the-safety-invariant-of-dyn-trait-to-require-a-sufficiently-valid-vtable">SISufficientlyValid: Extend the safety invariant of <code>dyn Trait</code> to require a &quot;sufficiently valid&quot; vtable</a></h3>
<p>As an alternative to modifying the validity invariant, we could modify the <a href="#validity-versus-safety-invariants">safety invariant</a> for wide pointers to include &quot;sufficiently valid&quot; metadata (see VISufficientlyValid for details). </p>
<p>Implications:</p>
<ul>
<li>Whenever one performs an upcast or other operation with a wide pointer, one must ensure that the metadata is &quot;sufficiently valid&quot;:</li>
<li>If the pointer is not initialized, and hence you don't know which vtable to use, you have the same options as described under VISufficientlyValid.</li>
</ul>
<p>The primary downsice of this proposal versus VISufficientlyValid is that the causes of UB are rather more subtle. Instead of UB occurring when the pointer is created, it occurs when an upcast occurs, and the locations for upcasts can be implicit (eg., any assignment or function call). Consider the following example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn noop(x: *mut dyn SuperTrait) { 
    /* look ma, empty body */
}

fn creator() {
    // No UB yet: the metadata for `x` is not sufficiently valid,
    // but we haven't done anything with it yet.
    let x: *mut dyn SubTrait = unsafe { std::mem::zeroed() };

    // `y = x` does not trigger UB, just a copy.
    let y = x;

    // UB! Here there is a coercion.
    noop(y);
}
<span class="boring">}
</span></code></pre></pre>
<p>For this reason, it would probably be &quot;best practice&quot; to treat this condition &quot;as if&quot; it were part of the validity invariant.</p>
<h3 id="sifullyvalid-extend-safety-condition-to-require-a-fully-valid-vtable-still-possible-in-the-future"><a class="header" href="#sifullyvalid-extend-safety-condition-to-require-a-fully-valid-vtable-still-possible-in-the-future">SIFullyValid: Extend safety condition to require a &quot;fully valid&quot; vtable (still possible in the future)</a></h3>
<p>This would permit safe code to read values from the vtable of a <code>*const dyn Trait</code> without any unsafety (just as it does for upcasting). It's not clear why we would want to permit this, and it may foreclose useful options in the future.</p>
<p>Adopting this option remains a possibility in the future, as it would be a backwards compatible extension to the above rule.</p>
<h3 id="sistructvalid-extend-safety-condition-to-require-a-structurally-valid-vtable-still-possible-in-the-future"><a class="header" href="#sistructvalid-extend-safety-condition-to-require-a-structurally-valid-vtable-still-possible-in-the-future">SIStructValid: Extend safety condition to require a &quot;structurally valid&quot; vtable (still possible in the future)</a></h3>
<p>Instead of requiring a valid vtable, we could require a &quot;structurally valid&quot; vtable. This vtable would have null pointers for all methods as well as a dummy type-id but would have the same &quot;structure&quot; as an ordinary vtable. There would be an intrinsic that gives access to the vtable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dummy_vtable::&lt;T: ?Sized&gt;() -&gt; T::Metadata
<span class="boring">}
</span></code></pre></pre>
<p>This would permit one to represent an uninitialized dyn pointer as <code>*const dyn Foo</code> and use the dummy-vtable for its metadata. This could be convenient, but is less typesafe than <code>MaybeUnit</code> or <code>Option&lt;NonNull&gt;</code> and not obviously better.</p>
<p>Adopting this option remains a possibility in the future, as it would be a backwards compatible extension to the above rule.</p>
<h3 id="nullvtable-special-case-the-vtable-for-null-still-possible-in-the-future"><a class="header" href="#nullvtable-special-case-the-vtable-for-null-still-possible-in-the-future">NullVtable: Special case the vtable for null (still possible in the future)</a></h3>
<p>Instead of saying that a &quot;null dyn pointer&quot; must have a structurally sound vtable, we could permit null as the value for the vtable. This would require an &quot;if branch&quot; or some kind of more complex logic in the upcasting path, since we couldn't unconditionally do a load. That might be acceptable, but it seems silly to slow down the upcasting path for a relatively unusual case of having a null </p>
<h3 id="flatvtable-adjust-vtable-layout-to-not-require-a-load-still-possible-in-the-future"><a class="header" href="#flatvtable-adjust-vtable-layout-to-not-require-a-load-still-possible-in-the-future">FlatVtable: Adjust vtable layout to not require a load (still possible in the future)</a></h3>
<p>We could adjust the vtable layout for a subtrait to include embedded copies of all supertraits. This way the upcast is a pure offset operation and does not require a load. This would be less efficient in terms of space usage. We generally prefer not to limit the possible vtable designs that an implementation can use unless we have to, so as to leave room for future developments.</p>
<h2 id="appendices"><a class="header" href="#appendices">Appendices</a></h2>
<h3 id="validity-versus-safety-invariants"><a class="header" href="#validity-versus-safety-invariants">Validity versus safety invariants</a></h3>
<p>Let us take a digression to cover Ralf's distinction of <a href="https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html">validity vs safety invariants</a>:</p>
<ul>
<li>The <strong>validity invariant</strong> for a type <code>T</code> defines the invariant that <strong>all values of type T must meet, all of the time</strong>. These invariants are respected in both safe and unsafe code and are primarily used to do layout optimizations. 
<ul>
<li>For example, the validity invariant of <code>bool</code> requires that the value is 0 or 1 but not 2. Thanks to this validity invariant, <code>Option&lt;bool&gt;</code> can be represented by the compiler in the same amount of space as <code>bool</code>.</li>
</ul>
</li>
<li>The <strong>safety invariant</strong> for a type <code>T</code> defines the invariant that <strong>all values of type <code>T</code> must meet when given to safe code</strong>. These invariants are used to justify unsafe code, but aren't understood by the compiler.
<ul>
<li>For example, a vector has a field for its length and capacity, and the safety invariant requires that they accurately describe the allocate space available in the vector's buffer (and aren't just random values). Thanks to this safety invariant, we can create <code>push</code> as a safe function: it can read those fields and rely on them being accurate to decide whether the memory still has any free capacity.</li>
</ul>
</li>
</ul>
<h3 id="metadata-and-field-offsets"><a class="header" href="#metadata-and-field-offsets">Metadata and field offsets</a></h3>
<p>Consider these struct definitions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RefCounted&lt;T&gt; {
    counter: usize,
    data: T,
}

struct Foo&lt;U&gt; {
    field: u32,
    data: U
}
<span class="boring">}
</span></code></pre></pre>
<p>and now assume that I have a <code>*const RefCounted&lt;Foo&lt;u32&gt;&gt;</code> which is coerced:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pointer1: *const RefCounted&lt;Foo&lt;u32&gt;&gt; = ...;
let pointer2: *const RefCounted&lt;Foo&lt;dyn Debug&gt;&gt; = pointer1;
<span class="boring">}
</span></code></pre></pre>
<p>If I now try to get the address of the field <code>field</code>...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pointer3: *const u32 = unsafe { raw_addr!((*pointer2).data.field) };
<span class="boring">}
</span></code></pre></pre>
<p>...this operation requires valid metadata. This is because the offset of <code>field</code> is a function of the alignment of <code>Foo&lt;U&gt;</code>, which is a function of the alignment of <code>U</code>. In these cases, the compiler will load the alignment from the vtable and do the required address computations itself.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../design-discussions/upcast-safety-3-options.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../design-discussions/upcast-safety.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../design-discussions/upcast-safety-3-options.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../design-discussions/upcast-safety.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
