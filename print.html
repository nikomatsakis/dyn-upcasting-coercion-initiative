<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dyn upcast initiative</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html">üëã Welcome</a></li><li class="chapter-item "><a href="updates.html">‚úèÔ∏è Updates</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="updates/2021-oct.html">2021-Oct</a></li></ol></li><li class="chapter-item "><a href="CHARTER.html">üìú Charter</a></li><li class="chapter-item "><a href="explainer.html">üìö Explainer</a></li><li class="chapter-item "><a href="design-discussions/index.html">üí¨ Design discussions</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="design-discussions/definition.html">Definition</a></li><li class="chapter-item "><a href="design-discussions/upcast-safety-2.html">Upcast safety</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="design-discussions/upcast-safety.html">Older draft 1</a></li></ol></li><li class="chapter-item "><a href="design-discussions/vtable-layout.html">Vtable layout and runtime behavior</a></li></ol></li><li class="chapter-item "><a href="FAQ.html">üòï FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Dyn upcast initiative</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/dyn-upcasting-coercion-initiative" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="dyn-upcasting-coercion-initiative"><a class="header" href="#dyn-upcasting-coercion-initiative">Dyn upcasting coercion initiative</a></h1>
<p><img src="https://img.shields.io/badge/status-active-brightgreen.svg" alt="initiative status: active" /></p>
<h2 id="what-is-this"><a class="header" href="#what-is-this">What is this?</a></h2>
<p>This page tracks the work of the dyn upcasting coercion <a href="https://lang-team.rust-lang.org/initiatives.html">initiative</a>! To learn more about what we are trying to do, and to find out the people who are doing it, take a look at the <a href="./CHARTER.html">charter</a>. </p>
<h2 id="current-status"><a class="header" href="#current-status">Current status</a></h2>
<p>The following table lists of the stages of an initiative, along with links to the artifacts that will be produced during that stage.</p>
<table><thead><tr><th>Stage</th><th>State</th><th>Artifact(s)</th></tr></thead><tbody>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/proposal.html">Proposal</a></td><td>‚úÖ</td><td><a href="https://github.com/rust-lang/lang-team/issues/98">Proposal issue</a></td></tr>
<tr><td></td><td></td><td><a href="./CHARTER.html">Charter</a></td></tr>
<tr><td></td><td></td><td><a href="https://github.com/rust-lang/rust/issues/65991">Tracking issue</a></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/development.html">Development</a></td><td>ü¶Ä</td><td><a href="./explainer.html">Explainer</a></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/feature-complete.html">Feature complete</a></td><td>üí§</td><td>Stabilization report</td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/stabilized.html">Stabilized</a></td><td>üí§</td><td></td></tr>
</tbody></table>
<p>Key:</p>
<ul>
<li>‚úÖ -- phase complete</li>
<li>ü¶Ä -- phase in progress</li>
<li>üí§ -- phase not started yet</li>
</ul>
<h2 id="how-can-i-get-involved"><a class="header" href="#how-can-i-get-involved">How Can I Get Involved?</a></h2>
<ul>
<li>Check for 'help wanted' issues on this repository!</li>
<li>If you would like to help with development, please contact the <a href="./charter.html#membership">owner</a> to find out if there are things that need doing.</li>
<li>If you would like to help with the design, check the list of active <a href="./design-discussions/README.html">design discussions</a> first. </li>
<li>If you have questions about the design, you can file an issue, but be sure to check the <a href="./FAQ.html">FAQ</a> or the <a href="./design-discussions/README.html">design-discussions</a> first to see if there is already something that covers your topic.</li>
<li>If you are using the feature and would like to provide feedback about your experiences, please [open a &quot;experience report&quot; issue].</li>
<li>If you are using the feature and would like to report a bug, please open a regular issue.</li>
</ul>
<p>We also participate on <a href="https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits">Zulip</a>, feel free to introduce yourself over there and ask us any questions you have.</p>
<h2 id="building-documentation"><a class="header" href="#building-documentation">Building Documentation</a></h2>
<p>This repository is also an mdbook project. You can view and build it using the
following command.</p>
<pre><code>mdbook serve
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-updates"><a class="header" href="#-updates">‚úèÔ∏è Updates</a></h1>
<p>Lang-team initiatives give monthly updates. This section collects the updates from this initiative for posterity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2021-oct-lang-team-update"><a class="header" href="#2021-oct-lang-team-update">2021-Oct: Lang team update</a></h1>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li>Impl is largely ready</li>
<li>Blocked on deciding the question of <a href="updates/../design-discussions">upcast safety</a></li>
</ul>
<h2 id="goals-for-this-month"><a class="header" href="#goals-for-this-month">Goals for this month</a></h2>
<ul>
<li>Hold design meeting about upcast safety and reach a conclusion</li>
</ul>
<h2 id="deref-coercion"><a class="header" href="#deref-coercion">Deref coercion</a></h2>
<p>It was discovered in <a href="https://github.com/rust-lang/rust/issues/89190">#89190</a> that extending &quot;unsizing coercions&quot; to include upcasts can cause deref coercions not to trigger, if those deref coercions &quot;deref&quot; to a <code>dyn</code> type. Current plan is to issue future compatibility warnings in <a href="https://github.com/rust-lang/rust/pull/89461">#89461</a>, since the only known use of this is emulating the upcasting coercion (and hence the code will continue to work afterwards, but the Deref impl is not invoked).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn-upcast-charter"><a class="header" href="#dyn-upcast-charter">Dyn upcast Charter</a></h1>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<h3 id="summary-and-problem-statement"><a class="header" href="#summary-and-problem-statement">Summary and problem statement</a></h3>
<ul>
<li>Add the <code>trait_upcasting</code> feature to the language.</li>
</ul>
<h3 id="motivation-use-cases-and-solution-sketches"><a class="header" href="#motivation-use-cases-and-solution-sketches">Motivation, use-cases, and solution sketches</a></h3>
<ul>
<li>The <code>trait_upcasting</code> feature adds support for trait upcasting coercion. This allows a
trait object of type <code>dyn Bar</code> to be cast to a trait object of type <code>dyn Foo</code>
so long as <code>Bar: Foo</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span>#![feature(trait_upcasting)]

<span class="boring">fn main() {
</span>trait Foo {}

trait Bar: Foo {}

impl Foo for i32 {}

impl&lt;T: Foo + ?Sized&gt; Bar for T {}

let bar: &amp;dyn Bar = &amp;123;
let foo: &amp;dyn Foo = bar;
<span class="boring">}
</span></code></pre></pre>
<h3 id="non-goals"><a class="header" href="#non-goals">Non-goals</a></h3>
<ul>
<li>To support <code>dyn Trait1 + Trait2</code> for general traits (this syntax naturally works, and should continue to work, with auto traits).</li>
</ul>
<h2 id="membership"><a class="header" href="#membership">Membership</a></h2>
<table><thead><tr><th>Role</th><th>Github</th></tr></thead><tbody>
<tr><td>[Owner]</td><td><a href="https://github.com/crlf0710">crlf0710</a></td></tr>
<tr><td>[Liaison]</td><td><a href="https://github.com/nikomatsakis">nikomatsakis</a></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-explainer"><a class="header" href="#-explainer">üìö Explainer</a></h1>
<blockquote>
<p>The &quot;explainer&quot; is &quot;end-user readable&quot; documentation that explains how to use the feature being deveoped by this initiative.
If you want to experiment with the feature, you've come to the right place.
Until the feature enters &quot;feature complete&quot; form, the explainer should be considered a work-in-progress.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-questions"><a class="header" href="#design-questions">Design questions</a></h1>
<p>Catalogs various interesting design questions that have arisen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-qualitifies-as-a-dyn-upcasting-coercion"><a class="header" href="#what-qualitifies-as-a-dyn-upcasting-coercion">What qualitifies as a dyn upcasting coercion</a></h1>
<p>The condition comes from the existing infrastructure within the compiler.</p>
<p>Currently the unsizing coercion on a trait object type allows it to:</p>
<ol>
<li>
<p>Removing one or more auto traits. (i.e. <code>dyn Foo + Send: Unsize&lt;dyn Foo&gt;</code>)</p>
</li>
<li>
<p>Changing lifetime bounds according to subtyping rules. (<code>dyn Bar&lt;'static&gt;: Unsize&lt;dyn Bar&lt;'a&gt;&gt;</code>)</p>
</li>
<li>
<p>Changing the principal trait to one of its supertraits. (<code>dyn Goo: Unsize&lt;dyn Foo&gt;</code> where <code>Goo</code> is <code>trait Goo: Foo {}</code>)</p>
</li>
</ol>
<p>When the third rule is involved, this unsizing coercion is a dyn upcasting coercion.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn-upcast-safety"><a class="header" href="#dyn-upcast-safety">Dyn upcast safety</a></h1>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>This doc concerns possible resolutions for the following potential problem:</p>
<ul>
<li>Given:
<ul>
<li>unsize coercions of raw pointers are legal and stable in safe code</li>
<li>upcasting may require loading data from vtable</li>
</ul>
</li>
<li>If:
<ul>
<li>dyn upcast coercions are a kind of unsize coercion</li>
<li>the <a href="design-discussions/upcast-safety-2.html#validity-versus-safety-invariants">safety invariant</a> for <code>*const dyn Foo</code> permits an invalid vtable</li>
</ul>
</li>
<li>Then:
<ul>
<li>safe code could cause UB by upcasting a <code>*const dyn SubTrait</code> to a <code>*const dyn SuperTrait</code></li>
</ul>
</li>
</ul>
<p>The doc recommends:</p>
<ul>
<li>Defining the safety invariant for a <code>*const dyn Foo</code> to be a &quot;sufficiently valid&quot; vtable for <code>Foo</code>
<ul>
<li>the definition of &quot;sufficiently valid&quot; is intentionally left undefined except to say:
<ul>
<li>a fully valid vtable is also &quot;sufficiently valid&quot;</li>
<li>it permits upcasting from <code>*const dyn SubTrait</code> to <code>*const dyn SuperTrait</code> without UB</li>
</ul>
</li>
<li>this implies that the only way for users to produce a &quot;sufficiently valid&quot; vtable is with a fully valid one, but conversely safe code cannot rely on a <code>*const dyn Foo</code> having a <em>fully</em> valid vtable</li>
</ul>
</li>
</ul>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<h3 id="unsize-coercions-are-possible-in-safe-code"><a class="header" href="#unsize-coercions-are-possible-in-safe-code">Unsize coercions are possible in safe code</a></h3>
<p>A brief review of the <a href="https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md">DST coercion design</a>:</p>
<ul>
<li>The <code>PT: CoerceUnsized&lt;PU&gt;</code> trait indicates that a smart pointer <code>PT</code> can be coerced to a smart pointer <code>PU</code>
<ul>
<li>This trait is manually implemented for each smart pointer type, e.g. <code>impl&lt;T&gt; CoerceUnsized&lt;Rc&lt;U&gt;&gt; for Rc&lt;T&gt; where T: Unsize&lt;U&gt;</code>.</li>
<li>The compiler requires that <code>Rc&lt;T&gt; -&gt; Rc&lt;U&gt;</code> be a legal DST coercion per various built-in rules (e.g., <code>T</code> must be stored in the final field of the struct and cannot be behind another pointer indirection).</li>
<li>Example: <code>Rc&lt;String&gt;: CoerceUnsized&lt;Rc&lt;dyn Debug&gt;&gt;</code></li>
</ul>
</li>
<li>The <code>T: Unsize&lt;U&gt;</code> trait indicates that the <code>T: ?Sized</code> referent can be &quot;unsized&quot; to the reference <code>U</code>
<ul>
<li>This trait is automatically implemented by the compiler.</li>
<li>Example: <code>String: Unsize&lt;dyn Debug&gt;</code></li>
<li>Example: <code>[String; 32]: Unsize&lt;[String]&gt;</code></li>
</ul>
</li>
</ul>
<p>This design permits one to write generic code that performances unsized coercions, but the trait is unstable so this only works on nightly:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Unstable:
fn foo&lt;PT, PU&gt;(pt: PT) -&gt; PU 
where 
    PT: CoerceUnsized&lt;PU&gt;,
{
    pt
}
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=0b3aef50e32fb224bc053f7ef4640e94">Example</a></p>
<p>You can however coerce from a <code>*const T</code> to a <code>*const dyn Trait</code> in safe code on stable (<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=695eeb19aa21e4762b9f5025fea7176c">playground</a>):</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: *const u32 = &amp;32;
    let y: *const dyn std::fmt::Debug = x;
}
</code></pre></pre>
<h3 id="upcasting-dyn-subtrait-to-dyn-supertrait-is-considered-an-unsize-coercion"><a class="header" href="#upcasting-dyn-subtrait-to-dyn-supertrait-is-considered-an-unsize-coercion">Upcasting <code>dyn SubTrait</code> to <code>dyn SuperTrait</code> is considered an unsize coercion</a></h3>
<p>We implemented upcasting from one dyn trait to a supertrait as an upsizing coercion. This means that <code>dyn SubTrait: Unsize&lt;dyn SuperTrait&gt;</code>. This is a coercion because it requires adjusting the vtable.</p>
<h3 id="how-upcasting-coercions-adjust-the-vtable"><a class="header" href="#how-upcasting-coercions-adjust-the-vtable">How upcasting coercions adjust the vtable</a></h3>
<p>The vtable for a <code>dyn SubTrait</code> <a href="https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/vtable-layout.html">now embeds pointers</a> to the vtables for super traits. Upcasting therefore requires loading the new vtable for the supertrait from the specific slot within the subtrait's table.</p>
<p>There are alternatives we could use such that upcasting would be a pure integer adjustment with no load, but that would be less efficient in terms of space usage.</p>
<p>Although not directly relevant here, there is another operation that requires accessing the vtable, which is finding the offset of fields -- see <a href="design-discussions/upcast-safety-2.html#mfo">the discussion in the appendices</a> for details. This operation is however only permitted in unsafe code because it requires a dereference of the raw pointer.</p>
<h3 id="ergo-upcasting-raw-pointers-is-possible-in-safe-code"><a class="header" href="#ergo-upcasting-raw-pointers-is-possible-in-safe-code">Ergo, upcasting raw pointers is possible in safe code</a></h3>
<p>Without any further changes, the following upcasting is legal in safe Rust (<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=37e49f69ebf992856b07a430c4d5510f">playground</a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(trait_upcasting])]

<span class="boring">fn main() {
</span>trait Sub: Sup { }
trait Sup { }

fn convert(x: *const dyn Sub) -&gt; *const dyn Sup {
    x
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="raw-pointers-are-traditionally-permitted-to-be-garbage"><a class="header" href="#raw-pointers-are-traditionally-permitted-to-be-garbage">Raw pointers are traditionally permitted to be &quot;garbage&quot;</a></h3>
<p>A sized raw pointer like <code>*const u32</code> has no validity/safety invariants to speak of. It is not required to be aligned, it may be null, and it may point at arbitrary memory. This is why <code>Option&lt;*const u32&gt;</code> requires an extra word fo the discriminant and it is why dereferencing a raw pointer is unsafe.</p>
<p>However, as noted in the previous section:</p>
<ul>
<li>if upcasting raw pointers is possible in safe code and</li>
<li>if upcasting requires loading data from the vtable</li>
</ul>
<p>then the safety condition of <code>*const dyn Foo</code> must include a &quot;sufficiently valid&quot; vtable. Sufficiently valid means that it is &quot;structurally complete&quot; in that it contains valid pointers that can be loaded to do upcasting.</p>
<h3 id="what-do-we-do-for-null-or-garbage-data"><a class="header" href="#what-do-we-do-for-null-or-garbage-data">What do we do for null or garbage data?</a></h3>
<p>The challenge with <code>*const dyn Trait</code> is &quot;what do we do to make a null pointer&quot;? For better or worse, <code>*const T</code> pointers can traditionally be null: but when one creates a vtable, one is supposed to have some underlying data type to make the vtable for, and with a null pointer that is not possible.</p>
<h3 id="creating-a-const-dyn"><a class="header" href="#creating-a-const-dyn">Creating a <code>*const dyn</code></a></h3>
<p>If we wish to ensure a safety invariant for <code>*const dyn</code> values, we have to ask ourselves how one could go about producing such a value. There are currently two ways to create a <code>*const dyn Trait</code>, one safe and one unsafe:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/ptr/fn.from_raw_parts.html"><code>std::ptr::from_raw_parts</code></a> -- safe, unstable</li>
<li><a href="https://doc.rust-lang.org/std/mem/fn.transmute.html"><code>std::mem::transmute</code></a> -- unsafe, unwise</li>
</ul>
<p>There is also a third way to make a <code>*const T</code> that doesn't work for <code>dyn</code> now but which could be made to work:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/ptr/fn.null.html"><code>std::ptr::null</code></a> -- safe, stable, but currently limited only to <code>*const T</code> where <code>T: Sized</code></li>
</ul>
<p>Of these three:</p>
<ul>
<li><code>from_raw_parts</code> requires a valid vtable for <code>T</code> as argument, so it would meet the safety requirement</li>
<li><code>transmute</code> is unsafe, but it would indeed be a requirement that users of transmute must uphold</li>
<li><code>null</code>, if extended to unsized types, would be tricky -- we would need to have some way to get a &quot;dummy&quot; vtable that is structurally sound enough to permit upcasting, but which has (for example) null pointers for the actual methods. This is, however, eminently doable.</li>
</ul>
<h2 id="core-decision-to-be-made"><a class="header" href="#core-decision-to-be-made">Core decision to be made</a></h2>
<p>The core decision to be made is to choose between two paths:</p>
<ul>
<li>Splitting out &quot;unsafe&quot; unsizing operations from safe ones;
<ul>
<li>Unsizing operations on safe pointers like <code>&amp;dyn SubTrait</code> would continue to work as they do today.</li>
<li>Implicit unsizing operations on raw pointers like <code>*const dyn SubTrait</code> would work sometimes, but those unsizing operations that require the metadata meet some sort of condition would require an explicit function call (e.g. the proposal below adds an unsafe function <code>unsize_raw_pointer</code>).</li>
</ul>
</li>
<li>Raw pointers have a safety invariant that puts conditions on metadata 
<ul>
<li>There are degrees in terms of how strict those conditions can be,</li>
</ul>
</li>
</ul>
<p>The first option has the following advantages:</p>
<ul>
<li><em>It is forwards compatible:</em> If we split out some unsizing and make them unsafe, we can merge them again later by expanding what is safe (and deprecating whatever parts of the &quot;unstable unsize cast&quot; machinery has become stabilized).</li>
<li><em>Raw pointers retain the same safety invariant whether thin or wide:</em> Raw pointers have traditionally been permitted to be arbitrary values. UB arises only when an invalid pointer is <em>used</em> in some invalid way (e.g., dereferenced). Under the raw unsize model, this condition extends to the metadata. </li>
<li><em>It is explicit:</em></li>
</ul>
<p>The second option has the following advantages:</p>
<ul>
<li><em>It retains a parallel between all kinds of unsized pointers:</em> Under this model, we can talk about &quot;fat pointers&quot; as having certain kinds of safety invariants (e.g. metadata meets certain conditions). </li>
</ul>
<p>There may be other benefits to the second option-- for example, </p>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<h3 id="sisufficientlyvalid-preferred-extend-the-safety-invariant-of-dyn-trait-to-require-a-sufficiently-valid-vtable"><a class="header" href="#sisufficientlyvalid-preferred-extend-the-safety-invariant-of-dyn-trait-to-require-a-sufficiently-valid-vtable">SISufficientlyValid: Preferred: Extend the safety invariant of <code>dyn Trait</code> to require a &quot;sufficiently valid&quot; vtable</a></h3>
<p>Our preferred solution is to extend the safety invariant for raw pointers to require a &quot;sufficiently valid&quot; vtable. We don't specify the precise condition that makes a vtable &quot;sufficiently valid&quot; except to say that a fully valid vtable is &quot;sufficiently valid&quot;, and that a &quot;sufficiently valid&quot; vtable permits dyn upcasting without UB.</p>
<p>Implications:</p>
<ul>
<li>The only way to meet the safety invariant for a <code>*const dyn Trait</code> is to use a valid vtable for <code>Trait</code>.
<ul>
<li>In particular, we don't define what is &quot;sufficiently valid&quot; so you have to use something that is fully valid; at the same time, you cannot rely on the vtable for <code>*const dyn Trait</code> being fully valid yourself, only &quot;sufficiently valid&quot; (which is &quot;valid enough for upcast&quot; and that's it).</li>
</ul>
</li>
<li>If the pointer is not initialized, and hence you don't know which vtable to use, you have the following options:
<ul>
<li>Use a dummy vtable for any type, it doesn't matter which.</li>
<li>Use <code>MaybeUninit&lt;*const dyn Foo&gt;</code>, in which case no safety invariant is assumed.</li>
<li>Use <code>Option&lt;*const dyn Foo&gt;</code> and <code>None</code> instead of null: safer, wastes space.</li>
<li>Use <code>Option&lt;NonNull&lt;dyn Foo&gt;&gt;</code> and <code>None</code> instead of null: safer, generally better, perhaps less ergonomic.</li>
</ul>
</li>
</ul>
<h2 id="other-options"><a class="header" href="#other-options">Other options</a></h2>
<p>The following options were rejected. This section briefly explains why.</p>
<h3 id="rawunsafe-make-raw-pointer-upcasting-unsafe-not-possible-once-dyn-subtrait-unsizedyn-supertrait-is-stable"><a class="header" href="#rawunsafe-make-raw-pointer-upcasting-unsafe-not-possible-once-dyn-subtrait-unsizedyn-supertrait-is-stable">RawUnsafe: Make raw pointer upcasting unsafe (not possible once <code>dyn SubTrait: Unsize&lt;dyn SuperTrait&gt;</code> is stable)</a></h3>
<p>We could permit &quot;safe pointer&quot; upcasting but make raw pointer upcasting unsafe. This would require changing the design of the coercion traits somewhat. We would introduce a new &quot;magic trait&quot; <code>RawUnsize</code>, analogous to <code>Unsize</code> except that it doesn't permit upcasting or any other operations that could require valid metadata. We would then modify the impl of <code>CoerceUnsized</code> for raw pointers to be:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U&gt; CoerceUnsized&lt;*const U&gt; for *const T where
    T: Unsize&lt;U&gt; + ?Sized,
    U: ?Sized, 
<span class="boring">}
</span></code></pre></pre>
<p>and it would become</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U&gt; CoerceUnsized&lt;*const U&gt; for *const T where
    T: RawUnsize&lt;U&gt; + ?Sized,
    U: ?Sized, 
<span class="boring">}
</span></code></pre></pre>
<p>To support upcasting on raw pointers, we can then introduce some other intrinsic for doing raw pointer upcast, such as something like this (modulo stacked borrows, which this <em>particular</em> definition may invalidate):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Unsafefy condition: If the metadata for `T` must be valid.
pub unsafe fn unsize_raw_pointer&lt;T, U&gt;(t: *const T) -&gt; *const U
where
    T: Unsize&lt;U&gt;,
{
    let (_, t_metadata) = t.into_raw_parts();
    unsafe { &amp;*t }
}
<span class="boring">}
</span></code></pre></pre>
<p>So long as <code>Unsize</code> remains a strict superset of <code>RawUnsize</code>, we could change things in the future to make <code>RawUnsize</code> an alias for <code>Unsize</code> (or, if it is unstable, remove it altogether) and thus deprecate the <code>unsize_raw_pointer</code> function. This is therefore forwards compatible with the preferred proposal here as well as other things that say &quot;still possible in the future&quot;.</p>
<h3 id="sifullyvalid-extend-safety-condition-to-require-a-fully-valid-vtable-still-possible-in-the-future"><a class="header" href="#sifullyvalid-extend-safety-condition-to-require-a-fully-valid-vtable-still-possible-in-the-future">SIFullyValid: Extend safety condition to require a &quot;fully valid&quot; vtable (still possible in the future)</a></h3>
<p>This would permit safe code to read values from the vtable of a <code>*const dyn Trait</code> without any unsafety (just as it does for upcasting). It's not clear why we would want to permit this, and it may foreclose useful options in the future.</p>
<p>Adopting this option remains a possibility in the future, as it would be a backwards compatible extension to the above rule.</p>
<h3 id="sistructvalid-extend-safety-condition-to-require-a-structurally-valid-vtable-still-possible-in-the-future"><a class="header" href="#sistructvalid-extend-safety-condition-to-require-a-structurally-valid-vtable-still-possible-in-the-future">SIStructValid: Extend safety condition to require a &quot;structurally valid&quot; vtable (still possible in the future)</a></h3>
<p>Instead of requiring a valid vtable, we could require a &quot;structurally valid&quot; vtable. This vtable would have null pointers for all methods as well as a dummy type-id but would have the same &quot;structure&quot; as an ordinary vtable. There would be an intrinsic that gives access to the vtable:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dummy_vtable::&lt;T: ?Sized&gt;() -&gt; T::Metadata
<span class="boring">}
</span></code></pre></pre>
<p>This would permit one to represent an uninitialized dyn pointer as <code>*const dyn Foo</code> and use the dummy-vtable for its metadata. This could be convenient, but is less typesafe than <code>MaybeUnit</code> or <code>Option&lt;NonNull&gt;</code> and not obviously better.</p>
<p>Adopting this option remains a possibility in the future, as it would be a backwards compatible extension to the above rule.</p>
<h3 id="nullvtable-special-case-the-vtable-for-null-still-possible-in-the-future"><a class="header" href="#nullvtable-special-case-the-vtable-for-null-still-possible-in-the-future">NullVtable: Special case the vtable for null (still possible in the future)</a></h3>
<p>Instead of saying that a &quot;null dyn pointer&quot; must have a structurally sound vtable, we could permit null as the value for the vtable. This would require an &quot;if branch&quot; or some kind of more complex logic in the upcasting path, since we couldn't unconditionally do a load. That might be acceptable, but it seems silly to slow down the upcasting path for a relatively unusual case of having a null </p>
<h3 id="flatvtable-adjust-vtable-layout-to-not-require-a-load-still-possible-in-the-future"><a class="header" href="#flatvtable-adjust-vtable-layout-to-not-require-a-load-still-possible-in-the-future">FlatVtable: Adjust vtable layout to not require a load (still possible in the future)</a></h3>
<p>We could adjust the vtable layout for a subtrait to include embedded copies of all supertraits. This way the upcast is a pure offset operation and does not require a load. This would be less efficient in terms of space usage. We generally prefer not to limit the possible vtable designs that an implementation can use unless we have to, so as to leave room for future developments.</p>
<h2 id="appendices"><a class="header" href="#appendices">Appendices</a></h2>
<h3 id="validity-versus-safety-invariants"><a class="header" href="#validity-versus-safety-invariants">Validity versus safety invariants</a></h3>
<p>Let us take a digression to cover Ralf's distinction of <a href="https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html">validity vs safety invariants</a>:</p>
<ul>
<li>The <strong>validity invariant</strong> for a type <code>T</code> defines the invariant that <strong>all values of type T must meet, all of the time</strong>. These invariants are respected in both safe and unsafe code and are primarily used to do layout optimizations. 
<ul>
<li>For example, the validity invariant of <code>bool</code> requires that the value is 0 or 1 but not 2. Thanks to this validity invariant, <code>Option&lt;bool&gt;</code> can be represented by the compiler in the same amount of space as <code>bool</code>.</li>
</ul>
</li>
<li>The <strong>safety invariant</strong> for a type <code>T</code> defines the invariant that <strong>all values of type <code>T</code> must meet when given to safe code</strong>. These invariants are used to justify unsafe code, but aren't understood by the compiler.
<ul>
<li>For example, a vector has a field for its length and capacity, and the safety invariant requires that they accurately describe the allocate space available in the vector's buffer (and aren't just random values). Thanks to this safety invariant, we can create <code>push</code> as a safe function: it can read those fields and rely on them being accurate to decide whether the memory still has any free capacity.</li>
</ul>
</li>
</ul>
<h3 id="metadata-and-field-offsets"><a class="header" href="#metadata-and-field-offsets">Metadata and field offsets</a></h3>
<p>Consider these struct definitions:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RefCounted&lt;T&gt; {
    counter: usize,
    data: T,
}

struct Foo&lt;U&gt; {
    field: u32,
    data: U
}
<span class="boring">}
</span></code></pre></pre>
<p>and now assume that I have a <code>*const RefCounted&lt;Foo&lt;u32&gt;&gt;</code> which is coerced:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pointer1: *const RefCounted&lt;Foo&lt;u32&gt;&gt; = ...;
let pointer2: *const RefCounted&lt;Foo&lt;dyn Debug&gt;&gt; = pointer1;
<span class="boring">}
</span></code></pre></pre>
<p>If I now try to get the address of the field <code>field</code>...</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pointer3: *const u32 = unsafe { raw_addr!((*pointer2).data.field) };
<span class="boring">}
</span></code></pre></pre>
<p>...this operation requires valid metadata. This is because the offset of <code>field</code> is a function of the alignment of <code>Foo&lt;U&gt;</code>, which is a function of the alignment of <code>U</code>. In these cases, the compiler will load the alignment from the vtable and do the required address computations itself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upcast-safety"><a class="header" href="#upcast-safety">Upcast safety</a></h1>
<h2 id="scenario"><a class="header" href="#scenario">Scenario</a></h2>
<ul>
<li>Casting <code>*dyn Foo</code> to <code>*dyn Bar</code> requires adjusting the vtable from a vtable for <code>Foo</code> to one for <code>Bar</code></li>
<li>For raw pointers, the metadata can be supplied by the user with <code>from_raw_parts</code>
<ul>
<li>If that metadata is incorrect, this could cause UB:
<ul>
<li>our current vtable format requires loads, and the pointers may not be valid</li>
<li>a flat vtable layout could give rise to out-of-bounds loads</li>
</ul>
</li>
</ul>
</li>
<li>Unsafety is needed, but where?</li>
</ul>
<h2 id="options-1"><a class="header" href="#options-1">Options</a></h2>
<h3 id="unsafe-to-create-a-dyn-foo"><a class="header" href="#unsafe-to-create-a-dyn-foo">Unsafe to create a <code>*dyn Foo</code></a></h3>
<blockquote>
<p>Announce that every fat pointer needs to have valid metadata part. <del>Needs to switch the std::ptr::from_raw_parts{,_mut} APIs to be unsafe.</del> And updates other documentations.</p>
</blockquote>
<p><strong>Implication:</strong> Not able to create a &quot;null pointer&quot; version of <code>*dyn Foo</code> unless:</p>
<ul>
<li>You use <code>Option&lt;*dyn Foo&gt;</code>, of course</li>
<li>We create some kind of &quot;dummy&quot; vtable that is structurally correct but has no actual functions within it; we would need a function for creating &quot;valid-but-default&quot; metadata as part of custom DST</li>
</ul>
<p>Update:</p>
<ul>
<li>It was pointed out by <code>steffahn</code> that <code>std::ptr::from_raw_parts</code> won't create fat pointer with invalid metadata.</li>
<li>One of the remaining ways to create a pointer with invalid metadata is <a href="https://github.com/rust-lang/rust/issues/81513#issuecomment-798158332">by using <code>transmute</code></a>.</li>
</ul>
<p>Question:</p>
<ul>
<li>Does the language UB happen at <code>transmute</code> site or coercion site?</li>
</ul>
<h3 id="alter-vtable-layout-to-be-flat"><a class="header" href="#alter-vtable-layout-to-be-flat">Alter vtable layout to be flat</a></h3>
<blockquote>
<p>Make vtables &quot;flat&quot;, by removing all pointer indirections in vtables and appending all the data to the tail. This makes upcasting coercion codegen become adding an offset to the metadata scalar, so won't cause real UB. Will waste some more static bytes in multiple inheritance cases than before, might make embedded-dev people unhappy.</p>
</blockquote>
<p>Question from Niko:</p>
<ul>
<li>Is this sufficient? Does it imply we can't use <code>InBoundsGep</code>? Is that already true?</li>
</ul>
<h3 id="make-raw-pointer-unsizing-unsafe"><a class="header" href="#make-raw-pointer-unsizing-unsafe">Make raw pointer unsizing unsafe</a></h3>
<blockquote>
<p>Announce that raw pointer unsizing coercion must happen in unsafe blocks, while other unsizing coercions can happen outside an unsafe block. This is actually a small breaking change. So need a future compat lint to migrate existing users dealing with raw pointers and some more changes to std(POC PR at #88239 explains the details but it's a bit long). A few other MIR-level details become observable by user: whether the compiler thinks it's a unsizing coercion or not.</p>
<p>nikomatsakis: (cc @RalfJ, if you happen to be around)</p>
</blockquote>
<h2 id="conversation-log"><a class="header" href="#conversation-log">Conversation log</a></h2>
<ul>
<li><a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/object.20upcasting.html#250616592">2021-08-25</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vtable-format-to-support-dyn-upcasting-coercion"><a class="header" href="#vtable-format-to-support-dyn-upcasting-coercion">Vtable format to support dyn upcasting coercion</a></h1>
<p>This current design was proposed by <code>Mario Carneiro</code> based on previous proposals on <a href="https://zulip-archive.rust-lang.org/stream/243200-t-lang/major-changes/topic/Trait.20Upcasting.20lang-team.2398.html#242876426">Zulip discussion</a>. It's a hybrid approach taking the benefits of both a &quot;flat&quot; design, and a &quot;pointer&quot;-based design.</p>
<p>This is implemented in <a href="https://github.com/rust-lang/rust/pull/86461">#86461</a>.</p>
<p>The vtable is generated by this algorithm in principle for a type <code>T</code> and a trait <code>Tr</code>:</p>
<ol>
<li>First emit the header part, including <code>MetadataDropInPlace</code>, <code>MetadataSize</code>, <code>MetadataAlign</code> items.</li>
<li>Create a tree of all the supertraits of this <code>TraitRef</code>, by filtering out all of duplicates.</li>
<li>Collect a set of <code>TraitRef</code>s consisting the trait and its first supertrait and its first supertrait's super trait,... and so on. Call this set <code>PrefixSet</code></li>
<li>Traverse the tree in post-order, for each <code>TraitRef</code> emit all its associated functions as either <code>Method</code> or <code>Vacant</code> entries. If this <code>TraitRef</code> is not in <code>PrefixSet</code>, emit a <code>TraitVPtr</code> containing a constant pointer to the vtable generated for the type <code>T</code> and this <code>TraitRef</code>.</li>
</ol>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait A {
    fn foo_a(&amp;self) {}
}

trait B: A {
    fn foo_b(&amp;self) {}
}

trait C: A {
    fn foo_c(&amp;self) {}
}

trait D: B + C {
    fn foo_d(&amp;self) {}
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-text">Vtable entries for `&lt;S as D&gt;`: [
    MetadataDropInPlace,
    MetadataSize,
    MetadataAlign,
    Method(&lt;S as A&gt;::foo_a),
    Method(&lt;S as B&gt;::foo_b),
    Method(&lt;S as C&gt;::foo_c),
    TraitVPtr(&lt;S as C&gt;),
    Method(&lt;S as D&gt;::foo_d),
]

Vtable entries for `&lt;S as C&gt;`: [
    MetadataDropInPlace,
    MetadataSize,
    MetadataAlign,
    Method(&lt;S as A&gt;::foo_a),
    Method(&lt;S as C&gt;::foo_c),
]
</code></pre>
<h2 id="runtime-behavior-for-dyn-upcasting-coercion"><a class="header" href="#runtime-behavior-for-dyn-upcasting-coercion">Runtime behavior for dyn upcasting coercion</a></h2>
<p>At the codegen time, the same algorithm above is performed for the source principal trait and the source trait object type. If the target principal trait is in the <code>PrefixSet</code> set, this coercion is a no-op.</p>
<p>If the target principal trait is not in the <code>PrefixSet</code>, generate code that read the data pointer from the
corresponding <code>TraitVPtr</code> slot.</p>
<h1 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h1>
<h2 id="flat-design"><a class="header" href="#flat-design">Flat design</a></h2>
<p>The vtable is generated by this algorithm in principle for a type <code>T</code> and a trait <code>Tr</code>:</p>
<ol>
<li>Create a tree of all the supertraits of this <code>TraitRef</code>, duplicate for the cyclic cases.</li>
<li>Traverse the tree in post-order, for each <code>TraitRef</code>, 
<ol>
<li>if it has no supertrait, emit a header part, including <code>MetadataDropInPlace</code>, <code>MetadataSize</code>, <code>MetadataAlign</code> items.</li>
<li>emit all its associated functions as either <code>Method</code> or <code>Vacant</code> entries.</li>
</ol>
</li>
</ol>
<h3 id="cons"><a class="header" href="#cons">Cons</a></h3>
<p>If there is a lot of diamond inheritance that could result in exponential blowup of the vtable
for example, <code>trait A(n+1): Bn + Cn {}, trait Bn: An { fn bn(&amp;self); }, trait Cn: An { fn cn(&amp;self); }</code></p>
<p><code>the vtable for An will contain 2^n DSAs</code></p>
<h2 id="pointer-based-design"><a class="header" href="#pointer-based-design">Pointer-based design</a></h2>
<p>All traits have their own vtables, and embedded all links to supertraits in the vtables</p>
<h3 id="cons-1"><a class="header" href="#cons-1">Cons</a></h3>
<p>Codegen regression for single-inheritance cases, which is very widely used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-faq"><a class="header" href="#-faq">üòï FAQ</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
