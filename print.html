<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dyn upcast initiative</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html">üëã Welcome</a></li><li class="chapter-item "><a href="updates.html">‚úèÔ∏è Updates</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="updates/2021-oct.html">2021-Oct</a></li></ol></li><li class="chapter-item "><a href="CHARTER.html">üìú Charter</a></li><li class="chapter-item "><a href="explainer.html">üìö Explainer</a></li><li class="chapter-item "><a href="design-discussions/index.html">üí¨ Design discussions</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="design-discussions/definition.html">Definition</a></li><li class="chapter-item "><a href="design-discussions/upcast-safety-3.html">Upcast safety</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="design-discussions/upcast-safety-3-options.html">Detailed options</a></li><li class="chapter-item "><a href="design-discussions/upcast-safety-2.html">Older draft 2</a></li><li class="chapter-item "><a href="design-discussions/upcast-safety.html">Older draft 1</a></li></ol></li><li class="chapter-item "><a href="design-discussions/vtable-layout.html">Vtable layout and runtime behavior</a></li></ol></li><li class="chapter-item "><a href="FAQ.html">üòï FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Dyn upcast initiative</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/dyn-upcasting-coercion-initiative" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="dyn-upcasting-coercion-initiative"><a class="header" href="#dyn-upcasting-coercion-initiative">Dyn upcasting coercion initiative</a></h1>
<p><img src="https://img.shields.io/badge/status-active-brightgreen.svg" alt="initiative status: active" /></p>
<h2 id="what-is-this"><a class="header" href="#what-is-this">What is this?</a></h2>
<p>This page tracks the work of the dyn upcasting coercion <a href="https://lang-team.rust-lang.org/initiatives.html">initiative</a>! To learn more about what we are trying to do, and to find out the people who are doing it, take a look at the <a href="./CHARTER.html">charter</a>. </p>
<h2 id="current-status"><a class="header" href="#current-status">Current status</a></h2>
<p>The following table lists of the stages of an initiative, along with links to the artifacts that will be produced during that stage.</p>
<div class="table-wrapper"><table><thead><tr><th>Stage</th><th>State</th><th>Artifact(s)</th></tr></thead><tbody>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/proposal.html">Proposal</a></td><td>‚úÖ</td><td><a href="https://github.com/rust-lang/lang-team/issues/98">Proposal issue</a></td></tr>
<tr><td></td><td></td><td><a href="./CHARTER.html">Charter</a></td></tr>
<tr><td></td><td></td><td><a href="https://github.com/rust-lang/rust/issues/65991">Tracking issue</a></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/development.html">Development</a></td><td>ü¶Ä</td><td><a href="./explainer.html">Explainer</a></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/feature-complete.html">Feature complete</a></td><td>üí§</td><td>Stabilization report</td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/stabilized.html">Stabilized</a></td><td>üí§</td><td></td></tr>
</tbody></table>
</div>
<p>Key:</p>
<ul>
<li>‚úÖ -- phase complete</li>
<li>ü¶Ä -- phase in progress</li>
<li>üí§ -- phase not started yet</li>
</ul>
<h2 id="how-can-i-get-involved"><a class="header" href="#how-can-i-get-involved">How Can I Get Involved?</a></h2>
<ul>
<li>Check for 'help wanted' issues on this repository!</li>
<li>If you would like to help with development, please contact the <a href="./charter.html#membership">owner</a> to find out if there are things that need doing.</li>
<li>If you would like to help with the design, check the list of active <a href="./design-discussions/README.html">design discussions</a> first. </li>
<li>If you have questions about the design, you can file an issue, but be sure to check the <a href="./FAQ.html">FAQ</a> or the <a href="./design-discussions/README.html">design-discussions</a> first to see if there is already something that covers your topic.</li>
<li>If you are using the feature and would like to provide feedback about your experiences, please [open a &quot;experience report&quot; issue].</li>
<li>If you are using the feature and would like to report a bug, please open a regular issue.</li>
</ul>
<p>We also participate on <a href="https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits">Zulip</a>, feel free to introduce yourself over there and ask us any questions you have.</p>
<h2 id="building-documentation"><a class="header" href="#building-documentation">Building Documentation</a></h2>
<p>This repository is also an mdbook project. You can view and build it using the
following command.</p>
<pre><code>mdbook serve
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-updates"><a class="header" href="#-updates">‚úèÔ∏è Updates</a></h1>
<p>Lang-team initiatives give monthly updates. This section collects the updates from this initiative for posterity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2021-oct-lang-team-update"><a class="header" href="#2021-oct-lang-team-update">2021-Oct: Lang team update</a></h1>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li>Impl is largely ready</li>
<li>Blocked on deciding the question of <a href="updates/../design-discussions">upcast safety</a></li>
</ul>
<h2 id="goals-for-this-month"><a class="header" href="#goals-for-this-month">Goals for this month</a></h2>
<ul>
<li>Hold design meeting about upcast safety and reach a conclusion</li>
</ul>
<h2 id="deref-coercion"><a class="header" href="#deref-coercion">Deref coercion</a></h2>
<p>It was discovered in <a href="https://github.com/rust-lang/rust/issues/89190">#89190</a> that extending &quot;unsizing coercions&quot; to include upcasts can cause deref coercions not to trigger, if those deref coercions &quot;deref&quot; to a <code>dyn</code> type. Current plan is to issue future compatibility warnings in <a href="https://github.com/rust-lang/rust/pull/89461">#89461</a>, since the only known use of this is emulating the upcasting coercion (and hence the code will continue to work afterwards, but the Deref impl is not invoked).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn-upcast-charter"><a class="header" href="#dyn-upcast-charter">Dyn upcast Charter</a></h1>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<h3 id="summary-and-problem-statement"><a class="header" href="#summary-and-problem-statement">Summary and problem statement</a></h3>
<ul>
<li>Add the <code>trait_upcasting</code> feature to the language.</li>
</ul>
<h3 id="motivation-use-cases-and-solution-sketches"><a class="header" href="#motivation-use-cases-and-solution-sketches">Motivation, use-cases, and solution sketches</a></h3>
<ul>
<li>The <code>trait_upcasting</code> feature adds support for trait upcasting coercion. This allows a
trait object of type <code>dyn Bar</code> to be cast to a trait object of type <code>dyn Foo</code>
so long as <code>Bar: Foo</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span>#![feature(trait_upcasting)]

<span class="boring">fn main() {
</span>trait Foo {}

trait Bar: Foo {}

impl Foo for i32 {}

impl&lt;T: Foo + ?Sized&gt; Bar for T {}

let bar: &amp;dyn Bar = &amp;123;
let foo: &amp;dyn Foo = bar;
<span class="boring">}
</span></code></pre></pre>
<h3 id="non-goals"><a class="header" href="#non-goals">Non-goals</a></h3>
<ul>
<li>To support <code>dyn Trait1 + Trait2</code> for general traits (this syntax naturally works, and should continue to work, with auto traits).</li>
</ul>
<h2 id="membership"><a class="header" href="#membership">Membership</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Role</th><th>Github</th></tr></thead><tbody>
<tr><td>[Owner]</td><td><a href="https://github.com/crlf0710">crlf0710</a></td></tr>
<tr><td>[Liaison]</td><td><a href="https://github.com/nikomatsakis">nikomatsakis</a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="-explainer"><a class="header" href="#-explainer">üìö Explainer</a></h1>
<blockquote>
<p>The &quot;explainer&quot; is &quot;end-user readable&quot; documentation that explains how to use the feature being deveoped by this initiative.
If you want to experiment with the feature, you've come to the right place.
Until the feature enters &quot;feature complete&quot; form, the explainer should be considered a work-in-progress.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-questions"><a class="header" href="#design-questions">Design questions</a></h1>
<p>Catalogs various interesting design questions that have arisen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-qualitifies-as-a-dyn-upcasting-coercion"><a class="header" href="#what-qualitifies-as-a-dyn-upcasting-coercion">What qualitifies as a dyn upcasting coercion</a></h1>
<p>The condition comes from the existing infrastructure within the compiler.</p>
<p>Currently the unsizing coercion on a trait object type allows it to:</p>
<ol>
<li>
<p>Removing one or more auto traits. (i.e. <code>dyn Foo + Send: Unsize&lt;dyn Foo&gt;</code>)</p>
</li>
<li>
<p>Changing lifetime bounds according to subtyping rules. (<code>dyn Bar&lt;'static&gt;: Unsize&lt;dyn Bar&lt;'a&gt;&gt;</code>)</p>
</li>
<li>
<p>Changing the principal trait to one of its supertraits. (<code>dyn Goo: Unsize&lt;dyn Foo&gt;</code> where <code>Goo</code> is <code>trait Goo: Foo {}</code>)</p>
</li>
</ol>
<p>When the third rule is involved, this unsizing coercion is a dyn upcasting coercion.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn-upcast-safety"><a class="header" href="#dyn-upcast-safety">Dyn upcast safety</a></h1>
<p>This document proposes a resolution to the last outstanding question blocking <code>dyn</code> upcast.</p>
<p>Tracking issue: https://github.com/rust-lang/rust/issues/101336</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>We are trying to enable &quot;upcasts&quot; from a <code>dyn Trait</code> to its supertraits:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo_method(&amp;self);
}
trait Bar: Foo {
    fn bar_method(&amp;self);
}

let x: &amp;dyn Bar = /* ... */;
let y: &amp;dyn Foo = x; // compiles
<span class="boring">}
</span></code></pre></pre>
<p>The key factor for these upcasts is that they require adjusting the vtable. The current implementation strategy is that the vtables for the <code>Bar</code> trait embed pointers to a <code>Foo</code> vtable within them:</p>
<pre><code>+----------------------------+
| Bar vtable for some type T |
|----------------------------|
| Foo vtable                 | ----------&gt; +------------------+
| foo_method                 | -----+      | Foo vtable for T |
| bar_method                 | --+  |      |------------------|
+----------------------------+   |  |      | foo_method       | ---+
                                 |  |      +------------------+    |
                                 |  |                              |
                                 |  +---&gt; &lt;T as Foo&gt;::foo_method &lt;-+
                                 v
                     &lt;T as Bar&gt;::bar_method
                 
(this diagram is only meant to convey the general idea of the vtable
 layout, and doesn't represent the exact offsets we would use etc;
 in fact, with the current implementation,
 the first supertrait is stored 'inline' and hence no load is required)
</code></pre>
<p>This way, given a <code>&amp;dyn Bar</code> object, we convert its <code>Bar</code> vtable to the appropriate <code>Foo</code> vtable by loading the appropriate field.</p>
<p>Although we don't want to commit to a particular implementation strategy, we do want to leave room for this strategy. One implication is that performing an upcast may require loading from the vtable, which implies that the vtable must be a valid pointer to an actual Rust vtable. Although <code>&amp;dyn Bar</code> references would always contain a valid vtable, the same is not necessarily true for a raw pointer like <code>*const dyn Bar</code> or <code>*mut dyn Bar</code>. </p>
<p>In the language today, we only support &quot;noop upcasts&quot; that don't affect the vtable, and these are safe (e.g., converting from <code>*const dyn Foo + Send</code> to <code>*const dyn Foo</code>). If we extend the set of upcasts to permit vtable-adjusting upcasts, like <code>*const dyn Bar</code> to <code>*const dyn Foo</code>, this implies that, for safe code at least, all <code>*const dyn Trait</code> values must have a valid vtable, so that we know we can safely load the required field and perform the upcast.</p>
<p>On the other hand, we do not generally require raw <code>*mut T</code> pointers to point to valid data. In fact, we explicitly permit them to have any value, including null, and only require that they point to valid data when they are dereferenced. Because dereferencing a raw pointer is an unsafe operation, it has always been considered safe to expose an arbitrary raw pointer to unsafe code -- the unsafety arises when you take a raw pointer from an unknown source and dereference it, since unless you can trace the origin of that pointer you can't possible guarantee that it is valid to dereference.</p>
<p>This brings us to the conflict:</p>
<ul>
<li>It has historically been safe to &quot;release&quot; a raw pointer to safe code, but not safe to receive one (since you cannot know if it is valid).</li>
<li>It has historically been safe to upcast <code>*const dyn</code> values (e.g., <code>*const dyn Foo + Send</code> to <code>*const dyn Foo</code>). 
<ul>
<li>Unlike the upcasts we are considering now, this upcast does not require changing the vtable at runtime, but the distinction is subtle for end-users.</li>
<li>Moreover, there are future extensions (e.g., upcasting <code>*const dyn Foo + Bar</code> to <code>*const dyn Foo</code>) that would require adjusting the vtable much like the upcasts currently being stabilized. </li>
</ul>
</li>
</ul>
<h2 id="related-future-consideration-virtual-method-calls-on-raw-pointers"><a class="header" href="#related-future-consideration-virtual-method-calls-on-raw-pointers">Related future consideration: virtual method calls on raw pointers</a></h2>
<p>There have been requests to extend traits with the option to include raw pointer methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait PtrLike {
    fn is_null(v: *const Self) -&gt; bool;
}
<span class="boring">}
</span></code></pre></pre>
<p>These methods would be useful when writing unsafe code because having an <code>&amp;self</code> method requires satisfying the validity conditions of an <code>&amp;</code>-reference, which may not be possible. If we did have such methods, however, it raises the question of whether it would be safe to invoke <code>is_null</code> on a <code>*const dyn PtrLike</code> reference. Just as with upcasting, invoking a method from the vtable requires loading from the vtable, and hence requires a valid vtable generated by the compiler.</p>
<p>The solution we propose in this document also resolves this future dilemma.</p>
<h2 id="definitions-validity-vs-safety-invariant"><a class="header" href="#definitions-validity-vs-safety-invariant">Definitions: validity vs safety invariant</a></h2>
<p>We adopt the terms <em>validity</em> and <em>safety</em> invariant from the <a href="https://rust-lang.github.io/unsafe-code-guidelines/glossary.html">unsafe code guidelines</a>:</p>
<blockquote>
<p>The <em>validity invariant</em> is an invariant that all data must uphold any time it is accessed or copied in a typed manner. This invariant is known to the compiler and exploited by optimizations such as improved enum layout or eliding in-bounds checks.</p>
<p>The <em>safety invariant</em> is an invariant that safe code may assume all data to uphold. This invariant is used to justify which operations safe code can perform. The safety invariant can be temporarily violated by unsafe code, but must always be upheld when interfacing with unknown safe code. It is not relevant when arguing whether some program has UB, but it is relevant when arguing whether some code safely encapsulates its unsafety -- in other words, it is relevant when arguing whether some library is sound.</p>
</blockquote>
<p>In short, the <em>validity invariant</em> defines a condition that must always be true, even in unsafe code, and the <em>safety invariant</em> defines an invariant that unsafe code must guarantee before a value can be released to be used by arbitrary code.</p>
<h2 id="contours-of-the-solution-space"><a class="header" href="#contours-of-the-solution-space">Contours of the solution space</a></h2>
<p>We can fix this conflict in one of two basic ways:</p>
<p>First, <strong>we could make vtable-adjusting upcasts casts (and <code>*Self</code> method calls) unsafe</strong>. This is  difficult to implement and would require changes to the <code>Coerce</code> trait, which is already excessively complicated. In exchange, it offers at best marginal benefit: raw <code>*dyn</code> pointers can be released to safe code, but safe code can't do anything interesting with them. For this reason, we do not recommend this option.</p>
<p>If vtable-adjusting casts (and <code>*Self</code> method calls) are safe, then the <strong>safety invariant</strong> for <code>*dyn</code> types must be that their metadata points to a <strong>fully valid vtable</strong> (i.e., a vtable created by the compiler). This ensures safe code can perform upcasts or dynamic dispatch. This also implies that <code>std::ptr::null</code> (which is safe) cannot be extended to <code>T</code> where <code>T: ?Sized</code> unless further changes are made, since we would need to provide a valid vtable (it would be possible to permit a sentinel value, like null, to be used, but that would imply that upcasting must have a branch, making it less efficient).</p>
<p>There are, however, various options for the <strong>validity invariant</strong>, ranging from no invariant to requiring a fully valid vtable at all times. The strict invariants offer some benefits, such as the ability to have a niche for <code>*dyn</code> pointers. We survey the options here:</p>
<div class="table-wrapper"><table><thead><tr><th>Validity invariant for <code>*dyn</code> metadata</th><th>Supports niche</th><th>Can be initialized with <code>std::mem::zeroed</code></th><th>Constant initializer</th></tr></thead><tbody>
<tr><td>None</td><td></td><td>‚úÖ</td><td>‚úÖ</td></tr>
<tr><td>Word-aligned</td><td>‚úÖ</td><td>‚úÖ</td><td>‚úÖ</td></tr>
<tr><td>Word-aligned, non-null</td><td>‚úÖ</td><td></td><td>‚úÖ</td></tr>
<tr><td>Valid vtable</td><td>‚úÖ</td><td></td><td></td></tr>
</tbody></table>
</div>
<p>Explanations for the column titles:</p>
<ul>
<li>Validity invariant for <code>*dyn</code> metadata -- describes the invariant that applies to the metadata for a <code>*dyn</code> value.</li>
<li>Supports niche -- true if there is a niche value so that <code>sizeof(Option&lt;*const dyn Foo&gt;) == sizeof(*const dyn Foo)</code>.</li>
<li>Can be initialized with <code>std::mem::zeroed</code> -- true if <code>std::mem::zeroed</code> can be used to create a valid value (very convenient). This makes it trivial to innitialize a <code>*const dyn</code> with a dummy value, though the value cannot be released to safe code.</li>
<li>Constant initializer -- true if there is some constant value for <code>*const dyn Foo</code> that satisfies the validity invariant, no matter the trait <code>Foo</code>. This makes it easy to initialize a <code>*const dyn</code> with a dummy value, though the value cannot be released to safe code.</li>
</ul>
<p>Other points:</p>
<ul>
<li><code>*dyn</code> values <a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=bcd18cd3870ba98e2c59b527418f8f68">currently have a niche</a>.</li>
<li>Other pointer-like values (such as <code>fn</code> and <code>&amp;</code>-references) are expected to have a validity invariant of word-aligned, non-null.</li>
<li>Whichever option we use, we can backwards-compatibly move &quot;up the table&quot; and adopt a less-strict validity invariant without introducing UB into any extant programs.</li>
</ul>
<h2 id="proposal"><a class="header" href="#proposal">Proposal</a></h2>
<p>The proposal is as follows:</p>
<ul>
<li>Vtable-adjusting upcasts are <strong>safe operations</strong>. The upcast is UB if performed on a value without a valid vtable</li>
<li>As such, the &quot;safety invariant&quot; requires a <strong>fully valid vtable</strong>.</li>
<li>The &quot;validity invariant&quot; requires <code>*dyn</code> metadata to be <strong>word-aligned and non-null</strong>.</li>
</ul>
<p>Vtable-adjusting upcasts are defined as:</p>
<ul>
<li>Trait upcasts that alter the set of methods that can be invoked on the resulting value at runtime (e.g., <code>dyn Bar</code> to <code>dyn Foo</code> from the introduction). In particular, upcasts that simply add or remove auto-traits are not vtable-adjusting (e.g., <code>dyn Debug + Send</code> to <code>dyn Debug</code>).</li>
</ul>
<p>This approach...</p>
<ul>
<li>permits safe upcasting (and method calls, in the future);</li>
<li>preserves the existing niche for <code>*const dyn</code>;</li>
<li>is consistent with other validity requirements for &quot;pointer-like&quot; things such as <code>fn</code>;</li>
</ul>
<p>The rules also imply that...</p>
<ul>
<li>valid (i.e., compiler-generated) vtables are only required for a <code>*dyn</code> pointer when
<ul>
<li>the <code>*dyn</code> pointer is upcast (or invoke methods);</li>
<li>or, when the <code>*dyn</code> pointer is released to arbitrary code, because that code may upcast (or invoke methods).
<ul>
<li>By implication, extending <a href="https://doc.rust-lang.org/std/ptr/fn.null.html"><code>std::ptr::null</code></a> to permit <code>T: ?Sized</code> would not be safe.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Possible future changes...</p>
<ul>
<li>without introducing UB, we could loosen the validity invariant if desired, for example to permit NULL as a valid value in unsafe code.</li>
<li>without introducing UB, we could also loosen the safety invariant to permit a sentinel value (such as NULL), but that would require a branch or other check in the upcast code, which would be less efficient.</li>
</ul>
<h2 id="prior-links"><a class="header" href="#prior-links">Prior links</a></h2>
<ul>
<li><a href="https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/upcast-safety-2.html">Dyn safety write-up</a>, which includes links to prior write-ups</li>
<li><a href="design-discussions/./upcast-safety-3-options.html">Exhaustive set of validity invariants considered</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upcast-safety-options-considered"><a class="header" href="#upcast-safety-options-considered">Upcast safety options considered</a></h1>
<p>This document details a number of options that were considered while preparing the <a href="design-discussions/./upcast-safety-3.html">upcast-safety-3</a> proposal.</p>
<h2 id="summary-table"><a class="header" href="#summary-table">Summary table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>proposal</th><th>unconditional-upcast</th><th>can-create-from-zeroed</th><th>can-create-from-arbitrary-bits</th><th>niche-for-dyn</th><th>can-release-something-zeroed-to-safe</th></tr></thead><tbody>
<tr><td>fully-valid-vtable</td><td>:ballot_box_with_check:</td><td>:octagonal_sign:</td><td>:octagonal_sign:</td><td>:ballot_box_with_check:</td><td>:octagonal_sign:</td></tr>
<tr><td>null-placeholder</td><td>:octagonal_sign:</td><td>:ballot_box_with_check:</td><td>:octagonal_sign:</td><td>:ballot_box_with_check:</td><td>:octagonal_sign:</td></tr>
<tr><td>operations-are-ub</td><td>:ballot_box_with_check:</td><td>:ballot_box_with_check:</td><td>:ballot_box_with_check:</td><td>:octagonal_sign:</td><td>:octagonal_sign:</td></tr>
<tr><td>operations-are-ub-nza</td><td>:ballot_box_with_check:</td><td>:octagonal_sign:</td><td>:octagonal_sign:</td><td>:ballot_box_with_check:</td><td>:octagonal_sign:</td></tr>
</tbody></table>
</div>
<h2 id="true-no-matter-what"><a class="header" href="#true-no-matter-what">True no matter what</a></h2>
<ul>
<li><code>MaybeUnit&lt;*const dyn Foo&gt;</code> can be used to create an uninitialized <code>*const dyn Foo</code> easily, like with any other type.</li>
<li>If we add <code>*const self</code> methods (which we should), and permit those to be invoked from safe code (which would be consistent, given that one can invoke a <code>self</code> method defined on a <code>*const T</code> type in safe code), then it will be <em>unsound</em> (i.e., potentially allow safe code to create UB) to release a <code>*const dyn Foo</code> to safe code unless the vtable is <em>fully valid</em> (created by the compiler).</li>
<li>vtable layout is not defined.</li>
<li>No matter what proposal we adopt, if you create a <code>*const dyn Foo</code> with anything less than a fully valid vtable (including e.g. a null placeholder), <strong>you must not allow that to escape to arbitrary code</strong>
<ul>
<li>This is actually a consequence of wanting to support <code>*const self</code> methods and method dispatch -- it could conceivably be true only for a trait <code>Foo</code> is it includes a <code>*const self</code> method, since those are not yet legal. </li>
</ul>
</li>
</ul>
<h2 id="proposals"><a class="header" href="#proposals">Proposals</a></h2>
<h3 id="fully-valid-vtable"><a class="header" href="#fully-valid-vtable">fully-valid-vtable</a></h3>
<p>It is UB to create a <code>*const dyn Foo</code> unless the vtable is fully valid (given that vtable layouts are undefined, this means produced by the compiler for the time being).</p>
<p>If you need to create a <code>*const dyn Foo</code> and don't have a valid vtable available, you can use <code>MaybeUninit&lt;*const dyn Foo&gt;</code>, or a union, or <code>Option</code>, which is probably good practice.</p>
<p>Forwards compatibility:</p>
<ul>
<li>Given that vtable layouts are not defined, there isn't much you can do at present in unsafe code with a vtable besides invoking methods, upcasting, computing the size, or other such operations.</li>
<li>If we were to adopt other proposals that weaken the validity requirement, compatibility is a bit complex. At the time we make the change, all <code>*const dyn</code> values in extant code would have valid vtables. But people would be able to write code that created values with less-than-valid vtables (e.g., maybe null, etc, depending on what change we made). They would not however be able to give that code to other functions, even unsafe functions, unless those functions stated explicitly that they don't require the <code>*const dyn</code> value to have a fully valid vtable (i.e., they promised not to upcast it, etc).
<ul>
<li>This is effectively the same as the operations-are-ub proposal, even if we adopt it today. You can create invalid vtables, but you cannot allow them to escape.</li>
</ul>
</li>
</ul>
<h3 id="null-placeholder"><a class="header" href="#null-placeholder">null-placeholder</a></h3>
<p>It is UB to create a <code>*const dyn Foo</code> unless the vtable is &quot;sufficiently valid&quot;, except that NULL is permitted as a placeholder value.</p>
<p>This has the consequence that when we upcast, we have to check for NULL, which is less efficient.</p>
<p>Upshot:</p>
<ul>
<li>You may create a <code>*const dyn Foo</code> from <code>std::mem::zeroed</code>.</li>
<li>The only thing you can do on a <code>*const dyn Foo</code> that is zeroed is copy it and upcast it.
<ul>
<li><em>Currently</em>, this means you can release a <code>*const dyn Foo</code> to safe code, but if we were to add <code>*const self</code> methods, that might no longer be true, unless those methods are also prepared to deal with the null pointer in some way (e.g., abort?), or unless it's unsafe to invoke such a method (seems odd). But that's really an issue for <code>*const self</code> methods to deal with, since it's already true today.</li>
</ul>
</li>
<li>If receiving one from an unknown source, you can assume the vtable is either value for some type or NULL (of course, you can't assume anything about the <em>data</em> pointer, and vtable layouts are unknown, so it's not clear how useful that is).</li>
</ul>
<p>Forwards compatibility:</p>
<ul>
<li>We can adopt any other proposal later, but we might lose the niche.</li>
</ul>
<p>Notes:</p>
<ul>
<li>We can in theory support a niche with a value like 0x1 for the vtable? </li>
</ul>
<h3 id="operations-are-ub"><a class="header" href="#operations-are-ub">operations-are-ub</a></h3>
<p>There is no validity invariant for <code>*const dyn Foo</code> -- the vtable can be arbitrary. However, the only &quot;non-UB&quot; operation that you can do on a <code>*const dyn Foo</code> is to copy it, unless the vtable is known to be valid (produced by the compiler). Without a known valid vtable, all other options, including but not limited to the following, are UB:</p>
<ul>
<li>Upcasting it do <code>*const dyn Bar</code> (where <code>trait Foo: Bar</code>)</li>
<li>Invoking methods from <code>Foo</code> (not currently possible without arbitrary-self-types)</li>
<li>Creating a safe pointer type (e.g., <code>&amp;*foo</code>)</li>
</ul>
<p>Upshot:</p>
<ul>
<li>You can create a <code>*const dyn Bar</code> with <code>mem::zeroed</code>, but it must not escape to safe code (that would permit the safe code to create UB, and hence be unsound).</li>
<li>If you are going to do anything besides copy that value around, it must be known to have a valid vtable at that time, or UB will result.</li>
</ul>
<p>Forwards compatibility:</p>
<ul>
<li>If we adopt this proposal, we can't move to the others without introducing UB into otherwise valid code (consequence of the can-create-from-arbitrary-bits)</li>
</ul>
<h3 id="operations-are-ub-nza"><a class="header" href="#operations-are-ub-nza">operations-are-ub-nza</a></h3>
<p>The validity invariant for <code>*const dyn Foo</code> is that the vtable must be non-zero and aligned, ensuring a niche. However, -- the vtable can be arbitrary. However, the only &quot;non-UB&quot; operation that you can do on a <code>*const dyn Foo</code> is to copy it, unless the vtable is known to be valid (produced by the compiler). Without a known valid vtable, all other options, including but not limited to the following, are UB:</p>
<h2 id="properties"><a class="header" href="#properties">Properties</a></h2>
<h3 id="unconditional-upcast"><a class="header" href="#unconditional-upcast">unconditional-upcast</a></h3>
<p>If this property holds, then...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo: Bar { }

let x: *const dyn Foo = ...;
let y: *const dyn Bar = x;
<span class="boring">}
</span></code></pre></pre>
<p>can be done without any conditional operations.</p>
<h3 id="can-create-from-zeroed"><a class="header" href="#can-create-from-zeroed">can-create-from-zeroed</a></h3>
<p>If this property holds, then...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: *const dyn Foo = std::mem::zeroed();
<span class="boring">}
</span></code></pre></pre>
<p>...is not insta-UB.</p>
<h3 id="can-create-from-arbitrary-bits"><a class="header" href="#can-create-from-arbitrary-bits">can-create-from-arbitrary-bits</a></h3>
<p>If this property holds, then...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: *const dyn Foo = /* arbitrary bits */;
<span class="boring">}
</span></code></pre></pre>
<p>...is not insta-UB.</p>
<h3 id="niche-for-dyn"><a class="header" href="#niche-for-dyn">niche-for-dyn</a></h3>
<p>Raw pointers for sized types do not presently have niches -- but under some of these proposals, vtables could potentially act as a niche, such that <code>Option&lt;*const dyn Foo&gt;</code> has the same size as <code>*const dyn Foo</code>. This seems like a pretty niche (no pun intended) advantage, and is not clearly desirable, but it helps to illustrate certain things.</p>
<p>Note that in some cases this property would be lost if we made future 'forwards compatible' changes (e.g., by moving from a more restricted variant to operations-are-ub).</p>
<h2 id="removed-proposals"><a class="header" href="#removed-proposals">Removed proposals</a></h2>
<p>There were some ideas that turned out to not add value and were removed from the vtable.</p>
<h3 id="sufficiently-valid-vtable"><a class="header" href="#sufficiently-valid-vtable">sufficiently-valid-vtable</a></h3>
<p>An earlier doc proposed a &quot;sufficiently valid&quot; vtable as the condition, where it was only legal to create a <code>*const dyn Foo</code> with a valid vtable, but you could not generally assume the vtable was valid. However, it was pointed out that because vtable layout is unstable, it's not clear what this &quot;sufficiently valid&quot; language adds. </p>
<p>The original intent was to prevent unsafe code authors who receive a <code>*const dyn Foo</code> from assuming that the vtable was valid. The fear was that if we made changes that permitted a &quot;less than fully valid&quot; vtable, that unsafe code would now be getting fewer guaranteese than it had before. But given that vtable layouts are unstable, the code can't do much in practice, and in any case, if we <em>did</em> change the requirements, we could safe that &quot;unsafe code which doesn't say otherwise requires a fully valid vtable&quot;.</p>
<p>Spelling out the scenarios:</p>
<ol>
<li>when I release to safe code, full validity is required, because there are safe operations that require it</li>
<li>so if I write a safe function, I can always assume full validity on input</li>
<li>if I write an unsafe fn, in Rust <em>now</em> I can assume that I get full validity (because we defined that as the invariant), but the only thing I can do with that are defined operations at present (e.g., invoke methods, etc). If in the future we define the layout, I could read data from that vtable, but since it is required to be fully valid, that seems ok. In the future, we could loosen the validity requirement, but we would say that unsafe functions must explicitly state that they accept a <code>*const dyn</code> with a less than fully valid vtable (in other words, we'd have &quot;edition-like&quot; treatment of validity invariants.</li>
</ol>
<p>Regardless, it's not clear what kind of &quot;less than fully valid&quot; vtables we would accept. Some possibilities:</p>
<ul>
<li>Null placeholder.</li>
<li>A &quot;skeleton&quot; vtable that permits upcast but has invalid methods. Feels awfully niche, not worth it.</li>
</ul>
<h3 id=""><a class="header" href="#"></a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn-upcast-safety-1"><a class="header" href="#dyn-upcast-safety-1">Dyn upcast safety</a></h1>
<p><strong>NB: This document is outdated.</strong> <a href="design-discussions/./upcast-safety-3.html">Click here to see the latest version.</a></p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>This doc concerns possible resolutions for the following potential problem:</p>
<ul>
<li>Given:
<ul>
<li>unsize coercions of raw pointers are legal and stable in safe code</li>
<li>upcasting may require loading data from vtable</li>
</ul>
</li>
<li>If:
<ul>
<li>dyn upcast coercions are a kind of unsize coercion</li>
<li>the <a href="design-discussions/upcast-safety-2.html#validity-versus-safety-invariants">safety invariant</a> for <code>*const dyn Foo</code> permits an invalid vtable</li>
</ul>
</li>
<li>Then:
<ul>
<li>safe code could cause UB by upcasting a <code>*const dyn SubTrait</code> to a <code>*const dyn SuperTrait</code></li>
</ul>
</li>
</ul>
<p>The doc recommends:</p>
<ul>
<li>Defining the safety invariant for a <code>*const dyn Foo</code> to be a &quot;sufficiently valid&quot; vtable for <code>Foo</code>
<ul>
<li>the definition of &quot;sufficiently valid&quot; is intentionally left undefined except to say:
<ul>
<li>a fully valid vtable is also &quot;sufficiently valid&quot;</li>
<li>it permits upcasting from <code>*const dyn SubTrait</code> to <code>*const dyn SuperTrait</code> without UB</li>
</ul>
</li>
<li>this implies that the only way for users to produce a &quot;sufficiently valid&quot; vtable is with a fully valid one, but conversely safe code cannot rely on a <code>*const dyn Foo</code> having a <em>fully</em> valid vtable</li>
</ul>
</li>
</ul>
<h2 id="background-1"><a class="header" href="#background-1">Background</a></h2>
<h3 id="unsize-coercions-are-possible-in-safe-code"><a class="header" href="#unsize-coercions-are-possible-in-safe-code">Unsize coercions are possible in safe code</a></h3>
<p>A brief review of the <a href="https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md">DST coercion design</a>:</p>
<ul>
<li>The <code>PT: CoerceUnsized&lt;PU&gt;</code> trait indicates that a smart pointer <code>PT</code> can be coerced to a smart pointer <code>PU</code>
<ul>
<li>This trait is manually implemented for each smart pointer type, e.g. <code>impl&lt;T&gt; CoerceUnsized&lt;Rc&lt;U&gt;&gt; for Rc&lt;T&gt; where T: Unsize&lt;U&gt;</code>.</li>
<li>The compiler requires that <code>Rc&lt;T&gt; -&gt; Rc&lt;U&gt;</code> be a legal DST coercion per various built-in rules (e.g., <code>T</code> must be stored in the final field of the struct and cannot be behind another pointer indirection).</li>
<li>Example: <code>Rc&lt;String&gt;: CoerceUnsized&lt;Rc&lt;dyn Debug&gt;&gt;</code></li>
</ul>
</li>
<li>The <code>T: Unsize&lt;U&gt;</code> trait indicates that the <code>T: ?Sized</code> referent can be &quot;unsized&quot; to the reference <code>U</code>
<ul>
<li>This trait is automatically implemented by the compiler.</li>
<li>Example: <code>String: Unsize&lt;dyn Debug&gt;</code></li>
<li>Example: <code>[String; 32]: Unsize&lt;[String]&gt;</code></li>
</ul>
</li>
</ul>
<p>This design permits one to write generic code that performances unsized coercions, but the trait is unstable so this only works on nightly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Unstable:
fn foo&lt;PT, PU&gt;(pt: PT) -&gt; PU 
where 
    PT: CoerceUnsized&lt;PU&gt;,
{
    pt
}
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=0b3aef50e32fb224bc053f7ef4640e94">Example</a></p>
<p>You can however coerce from a <code>*const T</code> to a <code>*const dyn Trait</code> in safe code on stable (<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=695eeb19aa21e4762b9f5025fea7176c">playground</a>):</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: *const u32 = &amp;32;
    let y: *const dyn std::fmt::Debug = x;
}
</code></pre></pre>
<h3 id="upcasting-dyn-subtrait-to-dyn-supertrait-is-considered-an-unsize-coercion"><a class="header" href="#upcasting-dyn-subtrait-to-dyn-supertrait-is-considered-an-unsize-coercion">Upcasting <code>dyn SubTrait</code> to <code>dyn SuperTrait</code> is considered an unsize coercion</a></h3>
<p>We implemented upcasting from one dyn trait to a supertrait as an upsizing coercion. This means that <code>dyn SubTrait: Unsize&lt;dyn SuperTrait&gt;</code>. This is a coercion because it requires adjusting the vtable.</p>
<h3 id="how-upcasting-coercions-adjust-the-vtable"><a class="header" href="#how-upcasting-coercions-adjust-the-vtable">How upcasting coercions adjust the vtable</a></h3>
<p>The vtable for a <code>dyn SubTrait</code> <a href="https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/vtable-layout.html">now embeds pointers</a> to the vtables for super traits. Upcasting therefore requires loading the new vtable for the supertrait from the specific slot within the subtrait's table.</p>
<p>There are alternatives we could use such that upcasting would be a pure integer adjustment with no load, but that would be less efficient in terms of space usage.</p>
<p>Although not directly relevant here, there is another operation that requires accessing the vtable, which is finding the offset of fields -- see <a href="design-discussions/upcast-safety-2.html#mfo">the discussion in the appendices</a> for details. This operation is however only permitted in unsafe code because it requires a dereference of the raw pointer.</p>
<h3 id="ergo-upcasting-raw-pointers-is-possible-in-safe-code"><a class="header" href="#ergo-upcasting-raw-pointers-is-possible-in-safe-code">Ergo, upcasting raw pointers is possible in safe code</a></h3>
<p>Without any further changes, the following upcasting is legal in safe Rust (<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=37e49f69ebf992856b07a430c4d5510f">playground</a>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(trait_upcasting])]

<span class="boring">fn main() {
</span>trait Sub: Sup { }
trait Sup { }

fn convert(x: *const dyn Sub) -&gt; *const dyn Sup {
    x
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="raw-pointers-are-traditionally-permitted-to-be-garbage"><a class="header" href="#raw-pointers-are-traditionally-permitted-to-be-garbage">Raw pointers are traditionally permitted to be &quot;garbage&quot;</a></h3>
<p>A sized raw pointer like <code>*const u32</code> has no validity/safety invariants to speak of. It is not required to be aligned, it may be null, and it may point at arbitrary memory. This is why <code>Option&lt;*const u32&gt;</code> requires an extra word fo the discriminant and it is why dereferencing a raw pointer is unsafe.</p>
<p>However, as noted in the previous section:</p>
<ul>
<li>if upcasting raw pointers is possible in safe code and</li>
<li>if upcasting requires loading data from the vtable</li>
</ul>
<p>then the safety condition of <code>*const dyn Foo</code> must include a &quot;sufficiently valid&quot; vtable. Sufficiently valid means that it is &quot;structurally complete&quot; in that it contains valid pointers that can be loaded to do upcasting.</p>
<h3 id="what-do-we-do-for-null-or-garbage-data"><a class="header" href="#what-do-we-do-for-null-or-garbage-data">What do we do for null or garbage data?</a></h3>
<p>The challenge with <code>*const dyn Trait</code> is &quot;what do we do to make a null pointer&quot;? For better or worse, <code>*const T</code> pointers can traditionally be null: but when one creates a vtable, one is supposed to have some underlying data type to make the vtable for, and with a null pointer that is not possible.</p>
<h3 id="creating-a-const-dyn"><a class="header" href="#creating-a-const-dyn">Creating a <code>*const dyn</code></a></h3>
<p>If we wish to ensure a safety invariant for <code>*const dyn</code> values, we have to ask ourselves how one could go about producing such a value. There are currently two ways to create a <code>*const dyn Trait</code>, one safe and one unsafe:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/ptr/fn.from_raw_parts.html"><code>std::ptr::from_raw_parts</code></a> -- safe, unstable</li>
<li><a href="https://doc.rust-lang.org/std/mem/fn.transmute.html"><code>std::mem::transmute</code></a> -- unsafe, unwise</li>
</ul>
<p>There is also a third way to make a <code>*const T</code> that doesn't work for <code>dyn</code> now but which could be made to work:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/ptr/fn.null.html"><code>std::ptr::null</code></a> -- safe, stable, but currently limited only to <code>*const T</code> where <code>T: Sized</code></li>
</ul>
<p>Of these three:</p>
<ul>
<li><code>from_raw_parts</code> requires a valid vtable for <code>T</code> as argument, so it would meet the safety requirement</li>
<li><code>transmute</code> is unsafe, but it would indeed be a requirement that users of transmute must uphold</li>
<li><code>null</code>, if extended to unsized types, would be tricky -- we would need to have some way to get a &quot;dummy&quot; vtable that is structurally sound enough to permit upcasting, but which has (for example) null pointers for the actual methods. This is, however, eminently doable.</li>
</ul>
<h3 id="interaction-raw-pointer-method-calls"><a class="header" href="#interaction-raw-pointer-method-calls">Interaction: Raw pointer method calls</a></h3>
<p>It would be useful if unsafe code could declare <code>*const self</code> and <code>*mut self</code> methods in traits</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FreeMe {
    pub unsafe fn free_me(*const self);
}
<span class="boring">}
</span></code></pre></pre>
<p>Given that using <code>&amp;self</code> implies (for ex</p>
<h2 id="core-decision-to-be-made"><a class="header" href="#core-decision-to-be-made">Core decision to be made</a></h2>
<p>The core decision to be made is to choose between two paths:</p>
<ul>
<li>Splitting out &quot;unsafe&quot; unsizing operations from safe ones;
<ul>
<li>Unsizing operations on safe pointers like <code>&amp;dyn SubTrait</code> would continue to work as they do today.</li>
<li>Implicit unsizing operations on raw pointers like <code>*const dyn SubTrait</code> would work sometimes, but those unsizing operations that require the metadata meet some sort of condition would require an explicit function call (e.g. the proposal below adds an unsafe function <code>unsize_raw_pointer</code>).</li>
</ul>
</li>
<li>Raw pointers have a validity or safety invariant that puts conditions on metadata 
<ul>
<li>There are options in terms of when this invariant must hold and how strict the invariant must be, but the upshot is that whenever you synthesize the metadata for a raw, wide pointer (e.g., from a transmute), you need to ensure that this metadata comes from some valid source, and is not just garbage. This is contrast to the data pointer, which can generally be arbitrary bytes (though not unininitialized).</li>
</ul>
</li>
</ul>
<h3 id="why-prefer-unsafe-raw-pointer-upcasting"><a class="header" href="#why-prefer-unsafe-raw-pointer-upcasting">Why prefer unsafe raw pointer upcasting?</a></h3>
<p>Raw pointers have traditionally been viewed as &quot;untrusted data until they are used&quot;. This is why dereferencing a raw pointer is unsafe: that's the point where it must be valid. It makes sense to extend this model to the metadata as well. When working with raw pointers and unsafe code, implicit operations like upcasting are a bug, not a feature, so it's useful to segregate them out and make them explicit via some kind of function call. It does require adding a new trait (see below) to the unsizing mechanism, but it only requires an internal &quot;implementation&quot; trait, and doesn't affect the &quot;main trait&quot; (<code>CoerceUnsized</code>).</p>
<p>Besides, so long as the validity/safety invariants remain in flux (which they will be for a while yet), this choice is forwards compatible with the others. We have the option to remove the &quot;unsafe upcast&quot; and merge it with safe upcast and strengthen the relevant invariant(s).</p>
<h3 id="why-prefer-unsafe-some-form-of-invariant"><a class="header" href="#why-prefer-unsafe-some-form-of-invariant">Why prefer unsafe some form of invariant?</a></h3>
<p>It's not clear why one would ever have invalid metadata in a wide pointer to start with; it's not an easy thing to do, you have to basically transmute from random bytes (e.g., zeroed memory). If you want to have a garbage pointer that is not yet initialized, use <code>MaybeUninit</code>. If you want a null pointer, use <code>ptr::null</code> or <code>Option&lt;Unique&lt;_&gt;&gt;</code>. In exchange for following these best practices, you get two things:</p>
<ul>
<li>Safe unsafe code overall, since you are being clearer about your intentions.</li>
<li>A simpler coercion model, with fewer traits and moving parts, and things that work the same for all kinds of pointers</li>
<li>A language that is </li>
</ul>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<p>The following options have been identified. The preferred solution is not yet clear.</p>
<h3 id="rawunsafe-make-raw-pointer-upcasting-unsafe-not-possible-once-dyn-subtrait-unsizedyn-supertrait-is-stable"><a class="header" href="#rawunsafe-make-raw-pointer-upcasting-unsafe-not-possible-once-dyn-subtrait-unsizedyn-supertrait-is-stable">RawUnsafe: Make raw pointer upcasting unsafe (not possible once <code>dyn SubTrait: Unsize&lt;dyn SuperTrait&gt;</code> is stable)</a></h3>
<p>We could permit &quot;safe pointer&quot; upcasting but make raw pointer upcasting unsafe. This would require changing the design of the coercion traits somewhat. We would introduce a new &quot;magic trait&quot; <code>RawUnsize</code>, analogous to <code>Unsize</code> except that it doesn't permit upcasting or any other operations that could require valid metadata. We would then modify the impl of <code>CoerceUnsized</code> for raw pointers to be:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U&gt; CoerceUnsized&lt;*const U&gt; for *const T where
    T: Unsize&lt;U&gt; + ?Sized,
    U: ?Sized, 
<span class="boring">}
</span></code></pre></pre>
<p>and it would become</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U&gt; CoerceUnsized&lt;*const U&gt; for *const T where
    T: RawUnsize&lt;U&gt; + ?Sized,
    U: ?Sized, 
<span class="boring">}
</span></code></pre></pre>
<p>To support upcasting on raw pointers, we can then introduce some other intrinsic for doing raw pointer upcast, such as something like this (modulo stacked borrows, which this <em>particular</em> definition may invalidate):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Unsafefy condition: If the metadata for `T` must be valid.
pub unsafe fn unsize_raw_pointer&lt;T, U&gt;(t: *const T) -&gt; *const U
where
    T: Unsize&lt;U&gt;,
{
    let (_, t_metadata) = t.into_raw_parts();
    unsafe { &amp;*t }
}
<span class="boring">}
</span></code></pre></pre>
<p>So long as <code>Unsize</code> remains a strict superset of <code>RawUnsize</code>, we could change things in the future to make <code>RawUnsize</code> an alias for <code>Unsize</code> (or, if it is unstable, remove it altogether) and thus deprecate the <code>unsize_raw_pointer</code> function. This is therefore forwards compatible with the preferred proposal here as well as other things that say &quot;still possible in the future&quot;.</p>
<h3 id="visufficientlyvalid-extend-the-validity-invariant-of-dyn-trait-to-require-a-sufficiently-valid-vtable"><a class="header" href="#visufficientlyvalid-extend-the-validity-invariant-of-dyn-trait-to-require-a-sufficiently-valid-vtable">VISufficientlyValid: Extend the validity invariant of <code>dyn Trait</code> to require a &quot;sufficiently valid&quot; vtable</a></h3>
<p>One solution is to extend the <a href="design-discussions/upcast-safety-2.html#validity-versus-safety-invariants">validity invariant</a> for raw pointers to require a &quot;sufficiently valid&quot; vtable. We don't specify the precise condition that makes a vtable &quot;sufficiently valid&quot; except to say that a fully valid vtable is &quot;sufficiently valid&quot;, and that a &quot;sufficiently valid&quot; vtable permits dyn upcasting without UB.</p>
<p>Implications:</p>
<ul>
<li>Whenever one creates a wide pointer, one must ensure that the metadata is &quot;sufficiently valid&quot;:
<ul>
<li>For <code>*const dyn Trait</code>, this would mean that one must use a valid vtable for <code>Trait</code>.
<ul>
<li>In particular, we don't define what is &quot;sufficiently valid&quot; so you have to use something that is fully valid; at the same time, you cannot rely on the vtable for <code>*const dyn Trait</code> being fully valid yourself, only &quot;sufficiently valid&quot; (which is &quot;valid enough for upcast&quot; and that's it).</li>
</ul>
</li>
</ul>
</li>
<li>If the pointer is not initialized, and hence you don't know which vtable to use, you have the following options:
<ul>
<li>Use a dummy vtable for any type, it doesn't matter which.</li>
<li>Use <code>MaybeUninit&lt;*const dyn Foo&gt;</code>, in which case no safety invariant is assumed.</li>
<li>Use <code>Option&lt;*const dyn Foo&gt;</code> and <code>None</code> instead of null: safer, wastes space.</li>
<li>Use <code>Option&lt;NonNull&lt;dyn Foo&gt;&gt;</code> and <code>None</code> instead of null: safer, generally better, perhaps less ergonomic.</li>
</ul>
</li>
</ul>
<p>One downside of this proposal is that the validity invariant is stricter than is needed: that is, the purpose of the validity invariant is primarily to enable the compiler's ability to perform layout optimizations. This rule would enable the compiler to silently insert upcasting operations if it needed to do so, but it's not clear why it would need to do that spontaneously: those operations are always tied to something else (e.g., a coercion or a method call). Therefore, the safety invariant might seem like a better fit.</p>
<h3 id="sisufficientlyvalid-extend-the-safety-invariant-of-dyn-trait-to-require-a-sufficiently-valid-vtable"><a class="header" href="#sisufficientlyvalid-extend-the-safety-invariant-of-dyn-trait-to-require-a-sufficiently-valid-vtable">SISufficientlyValid: Extend the safety invariant of <code>dyn Trait</code> to require a &quot;sufficiently valid&quot; vtable</a></h3>
<p>As an alternative to modifying the validity invariant, we could modify the <a href="design-discussions/upcast-safety-2.html#validity-versus-safety-invariants">safety invariant</a> for wide pointers to include &quot;sufficiently valid&quot; metadata (see VISufficientlyValid for details). </p>
<p>Implications:</p>
<ul>
<li>Whenever one performs an upcast or other operation with a wide pointer, one must ensure that the metadata is &quot;sufficiently valid&quot;:</li>
<li>If the pointer is not initialized, and hence you don't know which vtable to use, you have the same options as described under VISufficientlyValid.</li>
</ul>
<p>The primary downsice of this proposal versus VISufficientlyValid is that the causes of UB are rather more subtle. Instead of UB occurring when the pointer is created, it occurs when an upcast occurs, and the locations for upcasts can be implicit (eg., any assignment or function call). Consider the following example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn noop(x: *mut dyn SuperTrait) { 
    /* look ma, empty body */
}

fn creator() {
    // No UB yet: the metadata for `x` is not sufficiently valid,
    // but we haven't done anything with it yet.
    let x: *mut dyn SubTrait = unsafe { std::mem::zeroed() };

    // `y = x` does not trigger UB, just a copy.
    let y = x;

    // UB! Here there is a coercion.
    noop(y);
}
<span class="boring">}
</span></code></pre></pre>
<p>For this reason, it would probably be &quot;best practice&quot; to treat this condition &quot;as if&quot; it were part of the validity invariant.</p>
<h3 id="sifullyvalid-extend-safety-condition-to-require-a-fully-valid-vtable-still-possible-in-the-future"><a class="header" href="#sifullyvalid-extend-safety-condition-to-require-a-fully-valid-vtable-still-possible-in-the-future">SIFullyValid: Extend safety condition to require a &quot;fully valid&quot; vtable (still possible in the future)</a></h3>
<p>This would permit safe code to read values from the vtable of a <code>*const dyn Trait</code> without any unsafety (just as it does for upcasting). It's not clear why we would want to permit this, and it may foreclose useful options in the future.</p>
<p>Adopting this option remains a possibility in the future, as it would be a backwards compatible extension to the above rule.</p>
<h3 id="sistructvalid-extend-safety-condition-to-require-a-structurally-valid-vtable-still-possible-in-the-future"><a class="header" href="#sistructvalid-extend-safety-condition-to-require-a-structurally-valid-vtable-still-possible-in-the-future">SIStructValid: Extend safety condition to require a &quot;structurally valid&quot; vtable (still possible in the future)</a></h3>
<p>Instead of requiring a valid vtable, we could require a &quot;structurally valid&quot; vtable. This vtable would have null pointers for all methods as well as a dummy type-id but would have the same &quot;structure&quot; as an ordinary vtable. There would be an intrinsic that gives access to the vtable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dummy_vtable::&lt;T: ?Sized&gt;() -&gt; T::Metadata
<span class="boring">}
</span></code></pre></pre>
<p>This would permit one to represent an uninitialized dyn pointer as <code>*const dyn Foo</code> and use the dummy-vtable for its metadata. This could be convenient, but is less typesafe than <code>MaybeUnit</code> or <code>Option&lt;NonNull&gt;</code> and not obviously better.</p>
<p>Adopting this option remains a possibility in the future, as it would be a backwards compatible extension to the above rule.</p>
<h3 id="nullvtable-special-case-the-vtable-for-null-still-possible-in-the-future"><a class="header" href="#nullvtable-special-case-the-vtable-for-null-still-possible-in-the-future">NullVtable: Special case the vtable for null (still possible in the future)</a></h3>
<p>Instead of saying that a &quot;null dyn pointer&quot; must have a structurally sound vtable, we could permit null as the value for the vtable. This would require an &quot;if branch&quot; or some kind of more complex logic in the upcasting path, since we couldn't unconditionally do a load. That might be acceptable, but it seems silly to slow down the upcasting path for a relatively unusual case of having a null </p>
<h3 id="flatvtable-adjust-vtable-layout-to-not-require-a-load-still-possible-in-the-future"><a class="header" href="#flatvtable-adjust-vtable-layout-to-not-require-a-load-still-possible-in-the-future">FlatVtable: Adjust vtable layout to not require a load (still possible in the future)</a></h3>
<p>We could adjust the vtable layout for a subtrait to include embedded copies of all supertraits. This way the upcast is a pure offset operation and does not require a load. This would be less efficient in terms of space usage. We generally prefer not to limit the possible vtable designs that an implementation can use unless we have to, so as to leave room for future developments.</p>
<h2 id="appendices"><a class="header" href="#appendices">Appendices</a></h2>
<h3 id="validity-versus-safety-invariants"><a class="header" href="#validity-versus-safety-invariants">Validity versus safety invariants</a></h3>
<p>Let us take a digression to cover Ralf's distinction of <a href="https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html">validity vs safety invariants</a>:</p>
<ul>
<li>The <strong>validity invariant</strong> for a type <code>T</code> defines the invariant that <strong>all values of type T must meet, all of the time</strong>. These invariants are respected in both safe and unsafe code and are primarily used to do layout optimizations. 
<ul>
<li>For example, the validity invariant of <code>bool</code> requires that the value is 0 or 1 but not 2. Thanks to this validity invariant, <code>Option&lt;bool&gt;</code> can be represented by the compiler in the same amount of space as <code>bool</code>.</li>
</ul>
</li>
<li>The <strong>safety invariant</strong> for a type <code>T</code> defines the invariant that <strong>all values of type <code>T</code> must meet when given to safe code</strong>. These invariants are used to justify unsafe code, but aren't understood by the compiler.
<ul>
<li>For example, a vector has a field for its length and capacity, and the safety invariant requires that they accurately describe the allocate space available in the vector's buffer (and aren't just random values). Thanks to this safety invariant, we can create <code>push</code> as a safe function: it can read those fields and rely on them being accurate to decide whether the memory still has any free capacity.</li>
</ul>
</li>
</ul>
<h3 id="metadata-and-field-offsets"><a class="header" href="#metadata-and-field-offsets">Metadata and field offsets</a></h3>
<p>Consider these struct definitions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RefCounted&lt;T&gt; {
    counter: usize,
    data: T,
}

struct Foo&lt;U&gt; {
    field: u32,
    data: U
}
<span class="boring">}
</span></code></pre></pre>
<p>and now assume that I have a <code>*const RefCounted&lt;Foo&lt;u32&gt;&gt;</code> which is coerced:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pointer1: *const RefCounted&lt;Foo&lt;u32&gt;&gt; = ...;
let pointer2: *const RefCounted&lt;Foo&lt;dyn Debug&gt;&gt; = pointer1;
<span class="boring">}
</span></code></pre></pre>
<p>If I now try to get the address of the field <code>field</code>...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pointer3: *const u32 = unsafe { raw_addr!((*pointer2).data.field) };
<span class="boring">}
</span></code></pre></pre>
<p>...this operation requires valid metadata. This is because the offset of <code>field</code> is a function of the alignment of <code>Foo&lt;U&gt;</code>, which is a function of the alignment of <code>U</code>. In these cases, the compiler will load the alignment from the vtable and do the required address computations itself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upcast-safety"><a class="header" href="#upcast-safety">Upcast safety</a></h1>
<p><strong>NB: This document is outdated.</strong> <a href="design-discussions/./upcast-safety-3.html">Click here to see the latest version.</a></p>
<h2 id="scenario"><a class="header" href="#scenario">Scenario</a></h2>
<ul>
<li>Casting <code>*dyn Foo</code> to <code>*dyn Bar</code> requires adjusting the vtable from a vtable for <code>Foo</code> to one for <code>Bar</code></li>
<li>For raw pointers, the metadata can be supplied by the user with <code>from_raw_parts</code>
<ul>
<li>If that metadata is incorrect, this could cause UB:
<ul>
<li>our current vtable format requires loads, and the pointers may not be valid</li>
<li>a flat vtable layout could give rise to out-of-bounds loads</li>
</ul>
</li>
</ul>
</li>
<li>Unsafety is needed, but where?</li>
</ul>
<h2 id="options-1"><a class="header" href="#options-1">Options</a></h2>
<h3 id="unsafe-to-create-a-dyn-foo"><a class="header" href="#unsafe-to-create-a-dyn-foo">Unsafe to create a <code>*dyn Foo</code></a></h3>
<blockquote>
<p>Announce that every fat pointer needs to have valid metadata part. <del>Needs to switch the std::ptr::from_raw_parts{,_mut} APIs to be unsafe.</del> And updates other documentations.</p>
</blockquote>
<p><strong>Implication:</strong> Not able to create a &quot;null pointer&quot; version of <code>*dyn Foo</code> unless:</p>
<ul>
<li>You use <code>Option&lt;*dyn Foo&gt;</code>, of course</li>
<li>We create some kind of &quot;dummy&quot; vtable that is structurally correct but has no actual functions within it; we would need a function for creating &quot;valid-but-default&quot; metadata as part of custom DST</li>
</ul>
<p>Update:</p>
<ul>
<li>It was pointed out by <code>steffahn</code> that <code>std::ptr::from_raw_parts</code> won't create fat pointer with invalid metadata.</li>
<li>One of the remaining ways to create a pointer with invalid metadata is <a href="https://github.com/rust-lang/rust/issues/81513#issuecomment-798158332">by using <code>transmute</code></a>.</li>
</ul>
<p>Question:</p>
<ul>
<li>Does the language UB happen at <code>transmute</code> site or coercion site?</li>
</ul>
<h3 id="alter-vtable-layout-to-be-flat"><a class="header" href="#alter-vtable-layout-to-be-flat">Alter vtable layout to be flat</a></h3>
<blockquote>
<p>Make vtables &quot;flat&quot;, by removing all pointer indirections in vtables and appending all the data to the tail. This makes upcasting coercion codegen become adding an offset to the metadata scalar, so won't cause real UB. Will waste some more static bytes in multiple inheritance cases than before, might make embedded-dev people unhappy.</p>
</blockquote>
<p>Question from Niko:</p>
<ul>
<li>Is this sufficient? Does it imply we can't use <code>InBoundsGep</code>? Is that already true?</li>
</ul>
<h3 id="make-raw-pointer-unsizing-unsafe"><a class="header" href="#make-raw-pointer-unsizing-unsafe">Make raw pointer unsizing unsafe</a></h3>
<blockquote>
<p>Announce that raw pointer unsizing coercion must happen in unsafe blocks, while other unsizing coercions can happen outside an unsafe block. This is actually a small breaking change. So need a future compat lint to migrate existing users dealing with raw pointers and some more changes to std(POC PR at #88239 explains the details but it's a bit long). A few other MIR-level details become observable by user: whether the compiler thinks it's a unsizing coercion or not.</p>
<p>nikomatsakis: (cc @RalfJ, if you happen to be around)</p>
</blockquote>
<h2 id="conversation-log"><a class="header" href="#conversation-log">Conversation log</a></h2>
<ul>
<li><a href="https://zulip-archive.rust-lang.org/stream/144729-wg-traits/topic/object.20upcasting.html#250616592">2021-08-25</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vtable-format-to-support-dyn-upcasting-coercion"><a class="header" href="#vtable-format-to-support-dyn-upcasting-coercion">Vtable format to support dyn upcasting coercion</a></h1>
<p>This current design was proposed by <code>Mario Carneiro</code> based on previous proposals on <a href="https://zulip-archive.rust-lang.org/stream/243200-t-lang/major-changes/topic/Trait.20Upcasting.20lang-team.2398.html#242876426">Zulip discussion</a>. It's a hybrid approach taking the benefits of both a &quot;flat&quot; design, and a &quot;pointer&quot;-based design.</p>
<p>This is implemented in <a href="https://github.com/rust-lang/rust/pull/86461">#86461</a>.</p>
<p>The vtable is generated by this algorithm in principle for a type <code>T</code> and a trait <code>Tr</code>:</p>
<ol>
<li>First emit the header part, including <code>MetadataDropInPlace</code>, <code>MetadataSize</code>, <code>MetadataAlign</code> items.</li>
<li>Create a tree of all the supertraits of this <code>TraitRef</code>, by filtering out all of duplicates.</li>
<li>Collect a set of <code>TraitRef</code>s consisting the trait and its first supertrait and its first supertrait's super trait,... and so on. Call this set <code>PrefixSet</code></li>
<li>Traverse the tree in post-order, for each <code>TraitRef</code> emit all its associated functions as either <code>Method</code> or <code>Vacant</code> entries. If this <code>TraitRef</code> is not in <code>PrefixSet</code>, emit a <code>TraitVPtr</code> containing a constant pointer to the vtable generated for the type <code>T</code> and this <code>TraitRef</code>.</li>
</ol>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait A {
    fn foo_a(&amp;self) {}
}

trait B: A {
    fn foo_b(&amp;self) {}
}

trait C: A {
    fn foo_c(&amp;self) {}
}

trait D: B + C {
    fn foo_d(&amp;self) {}
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-text">Vtable entries for `&lt;S as D&gt;`: [
    MetadataDropInPlace,
    MetadataSize,
    MetadataAlign,
    Method(&lt;S as A&gt;::foo_a),
    Method(&lt;S as B&gt;::foo_b),
    Method(&lt;S as C&gt;::foo_c),
    TraitVPtr(&lt;S as C&gt;),
    Method(&lt;S as D&gt;::foo_d),
]

Vtable entries for `&lt;S as C&gt;`: [
    MetadataDropInPlace,
    MetadataSize,
    MetadataAlign,
    Method(&lt;S as A&gt;::foo_a),
    Method(&lt;S as C&gt;::foo_c),
]
</code></pre>
<h2 id="runtime-behavior-for-dyn-upcasting-coercion"><a class="header" href="#runtime-behavior-for-dyn-upcasting-coercion">Runtime behavior for dyn upcasting coercion</a></h2>
<p>At the codegen time, the same algorithm above is performed for the source principal trait and the source trait object type. If the target principal trait is in the <code>PrefixSet</code> set, this coercion is a no-op.</p>
<p>If the target principal trait is not in the <code>PrefixSet</code>, generate code that read the data pointer from the
corresponding <code>TraitVPtr</code> slot.</p>
<h1 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h1>
<h2 id="flat-design"><a class="header" href="#flat-design">Flat design</a></h2>
<p>The vtable is generated by this algorithm in principle for a type <code>T</code> and a trait <code>Tr</code>:</p>
<ol>
<li>Create a tree of all the supertraits of this <code>TraitRef</code>, duplicate for the cyclic cases.</li>
<li>Traverse the tree in post-order, for each <code>TraitRef</code>, 
<ol>
<li>if it has no supertrait, emit a header part, including <code>MetadataDropInPlace</code>, <code>MetadataSize</code>, <code>MetadataAlign</code> items.</li>
<li>emit all its associated functions as either <code>Method</code> or <code>Vacant</code> entries.</li>
</ol>
</li>
</ol>
<h3 id="cons"><a class="header" href="#cons">Cons</a></h3>
<p>If there is a lot of diamond inheritance that could result in exponential blowup of the vtable
for example, <code>trait A(n+1): Bn + Cn {}, trait Bn: An { fn bn(&amp;self); }, trait Cn: An { fn cn(&amp;self); }</code></p>
<p><code>the vtable for An will contain 2^n DSAs</code></p>
<h2 id="pointer-based-design"><a class="header" href="#pointer-based-design">Pointer-based design</a></h2>
<p>All traits have their own vtables, and embedded all links to supertraits in the vtables</p>
<h3 id="cons-1"><a class="header" href="#cons-1">Cons</a></h3>
<p>Codegen regression for single-inheritance cases, which is very widely used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-faq"><a class="header" href="#-faq">üòï FAQ</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
